---
title: "213-Discussion"
author: "Yu-Shiuan (Lily) Huang"
date: "Spring 2024"
output:
  html_document: 
    theme: paper
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      tidy.opts=list(width.cutoff = 80),
                      tidy = FALSE)
options(width = 80)

htmltools::tagList(
  xaringanExtra::use_clipboard(
    button_text = "<i class=\"fa fa-clipboard\" style=\"color: #4D5656\" ></i>",
    success_text = "<i class=\"fa fa-check\" style=\"color: #4D5656\"></i>",
    error_text = "<i class=\"fa fa-times-circle\" style=\"color: #4D5656\"></i>"
  ),
  rmarkdown::html_dependency_font_awesome()
)
```

```{css, echo=FALSE}
pre {
  max-height: 400px;
  overflow-y: auto;
}

pre[class] {
  max-height: 200px;
}
```

```{css, echo=FALSE}
.scroll-100 {
  max-height: 200px;
  overflow-y: auto;
  background-color: inherit;
}
```

#  {.tabset .tabset-fade .tabset-fill}

## Discussion I

For today's discussion, we will review the distinction between parametric and nonparametric regression models, as well as some key properties of simple linear regression. If you wish to review materials from POL 211 & 212, you can access them through the following links: [POL 211 Discussion](https://yslhuang.github.io/method-sequence/211-Discussion.html), [POL 212 Discussion](https://yslhuang.github.io/method-sequence/212-Discussion.html).

1. Parametric versus nonparametric Regression Models
2. Simple Linear Regression
3. Properties of Least Squares Estimator

### 1. Parametric versus nonparametric Regression Models

When it comes to regression analysis, choosing the right approach is crucial for accurate predictions and meaningful insights. Two common methods used are parametric, like linear regression, and semi/non-parametric, like smoothing spline regression or Kernal regression. Each has its own advantages and disadvantages, and the choice between them largely depends on the nature of the data and the underlying relationships.

#### a. What is parametric and semi/nonparametric regression?

**Parametric Regression** Linear regression is a well-known parametric method that assumes a linear functional form for the relationship between the predictors ($X$) and the target variable ($Y$). This approach has several benefits, such as ease of estimation with a small number of coefficients. In linear regression, these coefficients have straightforward interpretations, and statistical significance tests are readily applicable. However, parametric methods come with a significant limitation — they rely on the assumption that the specified functional form is a close approximation to the true relationship. If this assumption is far from reality, linear regression can perform poorly and yield unreliable results.

**Nonparametric Regression** On the other hand, non-parametric methods like K-Nearest Neighbors (KNN) regression do not make explicit assumptions about the functional form of the relationship between $X$ and $Y$. Instead, they provide a more flexible approach for regression. KNN regression identifies the K training observations closest to a prediction point and estimates the target variable by averaging their values. While this approach is more versatile and can handle complex relationships, it can suffer from high variance when K is small, leading to overfitting. Conversely, when K is large, KNN regression can underfit the data.

##### Example

Assume that we have a outcome variable $Y$ and two explanatory variables, $x_1$ and $x_2$. In general, the regression model that describes the relationship can be written as:

$$Y = f_1(x_1) + f_2(x_2) + \epsilon$$

- Some parametric regression models:

    - Multiple linear regression model: $Y = \beta_0 + \beta_1x_1 + \beta_2x_2 + \epsilon$
    - Polynomial regression model of second order: $Y = \beta_0 + \beta_{10}x_1 + \beta_{11}{x_1}^2 + \beta_{20}x_2 + \beta_{21}{x_2}^2 + \epsilon$
    - Nonlinear regression model: $Y = \beta_0 + \beta_1x_1 + \beta_2e^{\beta_3x_2} + \epsilon$
    - Poisson regression with $Y$ is count: $log(\mu) = \beta_0 + \beta_1x_1 + \beta_2x_2 + \epsilon$

- If we do not know $f_1$ and $f_2$ functions, we need to use a Nonparametric regression model.

#### b. Nonparametric regression estimation methods: K-Nearest Neighbors (KNN) regression

K-Nearest Neighbors (KNN) regression is one of the simplest and best-known nonparametric methods. Given a value for $K$ and a prediction point $x_0$, KNN regression first identifies the $K$ training observations that are closest to $x_0$, represented by $N_0$. It then estimates $f(x_0)$ using the average of all the training responses in $N_0$. In other words,

$$\hat{f}(x_0)=\frac{1}{K}\sum_{x_i \in N_0}y_i$$

<center>
![](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*joeNdWj6_H3rhAtZ5FXy1w.png){width=50%}
</center>
    
When using KNN as a regressor with a continuous dependent variable, data points are scattered across the coordinate plane. When a new data point is introduced, the number of neighbors ($K$) is determined using any of the distance metrics.Usually, the **Euclidean distance** is used as the distance metric. Once the neighbors are identified, the predicted value of the new data point is calculated as the average of all the neighbors' values combined.

<center>
![](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_i1PCxvSDw5TIfzyq90aag.png
){width=50%}
</center>

The below figure illustrates two KNN fits on a data set with $p = 2$ predictors. The fit with $K = 1$ is shown in the left-hand panel, while the right-hand panel corresponds to $K = 9$.We see that when $K = 1$, the KNN fit perfectly interpolates the training observations, and consequently takes the form of a step function. When $K = 9$, the KNN fit still is a step function, but averaging over nine observations results in much smaller regions of constant prediction, and consequently a smoother fit. In general, the optimal value for $K$ will depend on the *bias-variance tradeoff*, which Chris introduced in POL 212. A small value for $K$ provides the most flexible fit, which will have low bias but high variance. This variance is due to the fact that the prediction in a given region is entirely dependent on just one observation. In contrast, larger values of $K$ provide a smoother and less variable fit; the prediction in a region is an average of several points, and so changing one observation has a smaller effect. However, the smoothing may cause bias by masking some of the structure in $f(X)$.

<center>
![](/Users/yu-shiuanhuang/Desktop/method-sequence/figures/knn.png){width=60%}
</center>

The bias-variance tradeoff is a fundamental concept in machine learning that deals with the balance between the bias (error from overly simplistic assumptions) and variance (sensitivity to fluctuations in the training data) of a model. In the context of KNN (K-Nearest Neighbors), adjusting the value of K can help control this tradeoff.

- Low $K$ (e.g., $K=1$): Low bias, high variance. The model closely follows the training data, leading to high variance and sensitivity to noise. It can capture complex patterns but may overfit the training data.

- High $K$ (e.g., large $K$): High bias, low variance. The model averages over more data points, resulting in smoother predictions with lower variance but potentially higher bias. It may underfit the data by oversimplifying the underlying patterns.

Choosing an appropriate value for $K$ involves finding a balance between bias and variance to achieve optimal model performance. This tradeoff influences the model's ability to generalize to **unseen data**.

<center>
![](/Users/yu-shiuanhuang/Desktop/method-sequence/figures/bias_variance.png){width=50%}
</center>

There are no pre-defined statistical methods to find the most favorable value of $K$, but here is a typical way of how to choose an optimal $K$:

1. Initialize a random $K$ value and start computing.
2. Choosing a small value of $K$ leads to unstable decision boundaries.
3. The substantial $K$ value is better for classification as it leads to smoothening the decision boundaries.
4. Derive a plot between error rate and $K$ denoting values in a defined range. Then choose the $K$ value as having a minimum error rate.


#### c. When should we use parametric or nonparametric regression?

The key question is when to choose a parametric approach like linear regression over a non-parametric one such as KNN regression. The answer is straightforward: a parametric approach performs better when the chosen functional form is a close match to the true relationship, particularly in the presence of a linear relationship. If the specified functional form is far from the truth, and prediction accuracy is our goal, then the parametric method will perform poorly. For instance, if we assume a linear relationship between $X$ and $Y$ but the true relationship is far from linear, then the resulting model will provide a poor fit to the data, and any conclusions drawn from it will be suspect.

In contrast, non-parametric methods do not explicitly assume a parametric form for $f(X)$, and thereby provide an alternative and more flexible approach for performing regression.

To illustrate this point, let’s consider a few scenarios and use R to simulate them:

1. **Linear Relationship**: When the true relationship between $X$ and $Y$ is linear, linear regression outperforms nonparametric regression. Linear regression provides an almost perfect fit in this situation, as it closely matches the underlying relationship.

    ```{r, message=F}
set.seed(1234) # for replication
N <- 1000 # set up the sample size
x1 <- rnorm(N, mean = 10, sd = 3)
e <- rnorm(N, mean = 0, sd = 3) # set the errors to be normally distributed 
y <- 7 + 3*x1 + e # set the true y
df <- data.frame(id = 1:N, y = y, x1 = x1, e = e)
    ```

    In the above chunk, I specify the true $y$ to be a function of $x_1$ and $e$. The true values of the regression coefficients is 3 for $x_1$. The intercept is 7. Let's first plot the true relationship between $x_1$ and $y$!

    ```{r, message=F, fig.align='center', fig.width=5, fig.height=4}
library(tidyverse)
ggplot(data = df, aes(y = y, x = x1)) +
  geom_point(alpha = 0.6) +
  geom_smooth() +
  theme_bw()
    ```

    Let's begin by splitting the generated data into a training set, comprising 80% of the data, and a test set, comprising the remaining 20%.

    ```{r, message=F}
set.seed(1234) # set the seed to make the partition reproducible
train <- df %>% sample_frac(0.8) # should have 800 obs
test <- anti_join(df, train, by = 'id') # should have 200 obs
    ```

    Now, let's first apply the `lm()` function to our training set. We'll then use the coefficients estimated from this model to predict the y-values in the test set, followed by computing the mean squared error (MSE).

    ```{r, message=F}
fit <- lm(y ~ x1, data = train)
    ```

    ```{r, message=FALSE, echo=FALSE}
sjPlot::tab_model(fit, show.se = TRUE, string.se = "S.E.",
                  dv.labels = c("OLS"), string.pred = "Variables", 
                  string.ci = "C.I. (95%)", p.style = "stars", 
                  file = "output.html")
    ```

    ```{r, message=F}
test$y_hat <- predict(fit, newdata = data.frame(x1 = test$x1))

# compute mean squared error (MSE)
MSE_ols <- sum((test$y - test$y_hat)^2)/nrow(test)

MSE_ols
    ```

    The mean squared error (MSE) obtained by using OLS regression to estimate the relationship between $y$ and $x_1$ in the training set and then using the estimated coefficients to predict $y$ in the test set is 8.770813. Now, let's proceed to use KNN regression with various values of $K$ to observe how the MSE varies. 

    We will use the `knn.reg()` function from the `FNN` package for KNN regression. This function requires four arguments to be specified:

    - `train`: the predictors of the training data
    - `test`: the predictor values, $x$, at which we would like to make predictions
    - `y`: the response for the training data
    - `k`: the number of neighbors to consider

    ```{r, message=F, warning=F, error=F}
# install.packages("FNN")
library(FNN)
train_no_y <- train %>% select(x1) 
test_no_y <- test %>% select(x1) 
train_y <- train %>% select(y) 

yhat_k1 <- knn.reg(train = train_no_y, test = test_no_y, y = train_y, k = 1)
yhat_k1
    ```

    As observed from the above results, when setting $K = 1$ in `knn.reg()`, it provides the predicted $y$ values for the test set. Now, let's calculate the MSE for this prediction.

    ```{r, message=F}
MSE_k1 <- sum((test$y - yhat_k1$pred)^2)/nrow(test)
MSE_k1
    ```

    As you can see, the MSE when employing KNN regression with $K = 1$ is significantly higher than the MSE observed with OLS regression. Let's create a for loop and repeat this process for various values of $K$ to determine whether the MSE improves or worsens compared to the MSE when using OLS.

    ```{r, message=F, warning=F, error=F}
MSE_KNN <- c()

for (i in seq(1, 100, by = 2)){
  yhat_k <- knn.reg(train = train_no_y, test = test_no_y, y = train_y, k = i)
  MSE_k <- sum((test$y - yhat_k$pred)^2)/nrow(test)
  MSE_KNN <- c(MSE_KNN, MSE_k)
}

MSE_KNN
    ```

    ```{r, message=F, fig.align='center', fig.width=5, fig.height=4}
ggplot(data = data.frame(K = seq(1, 100, by = 2), MSE = MSE_KNN), 
       aes(y = MSE, x = K)) +
  geom_line(alpha = 0.4, color = "darkgreen") +
  geom_point(alpha = 0.3, color = "darkgreen") +
  geom_hline(yintercept = MSE_ols, color = "darkgray", 
             alpha = 0.8, linetype = "dashed") +
  annotate("text", x = 90, y = 18, label = "KNN", color = "darkgreen", alpha = 0.5) +
  annotate("text", x = 90, y = 17, label = "OLS", color = "darkgray") +
  theme_bw()
    ```

    After simulation, it's evident that when the true relationship between the variables of interest is linear, KNN regression doesn't offer superior predictions compared to OLS regression.

2. **Slight Non-Linearity**: In cases of slight non-linearity, where the true relationship deviates slightly from linearity, KNN regression can perform nearly as well as linear regression. It still provides reasonable results without a substantial reduction in prediction accuracy.

3. **Strong Non-Linearity**: However, in situations with a strong non-linear relationship, KNN regression outperforms linear regression. This is because KNN can adapt to complex relationships, providing more accurate predictions.

    ```{r, message=F}
set.seed(1234) # for replication
N <- 1000 # set up the sample size
x1 <- rnorm(N, mean = 1, sd = 10)
e <- rnorm(N, mean = 3, sd = 10) # set the errors to be normally distributed 
y <- 3 + 4*(x1+3)^2*(x1-1)^3 + e # set the true y
df <- data.frame(id = 1:N, y = y, x1 = x1, e = e)
    ```

    For example, let's now generate a relationship between $x_1$ and $y$ that is strongly non-linear. I specify the true $y$ to be a function of $x_1$ and $e$. Overall, the formula, $y = 3+4(x_1+3)^2(x_1-1)^3+e$,  describes a relationship where $y$ is influenced by $x_1$ in a nonlinear way, with two distinct "bumps" or curves, along with some random variability represented by $e$. 

    ```{r, message=F, fig.align='center', fig.width=5, fig.height=4}
library(tidyverse)
ggplot(data = df, aes(y = y, x = x1)) +
  geom_point(alpha = 0.6) +
  geom_smooth() +
  theme_bw()
    ```

    Following our previous approach, let's now compare the MSE obtained from OLS regression, used to estimate the relationship between $y$ and $x_1$, with the MSE derived from KNN regression, employing different values of $K$.

      - Step 1: Split the Sample in to Training and Test Set

        ```{r, message=F}
set.seed(1234) # set the seed to make the partition reproducible
train <- df %>% sample_frac(0.8) # should have 800 obs
test <- anti_join(df, train, by = 'id') # should have 200 obs
fit2 <- lm(y ~ x1, data = train)
        ```

      - Step 2: Run OLS Regression and Compute the MSE
    
        ```{r, message=F}
fit2 <- lm(y ~ x1, data = train)
        ```
    
        ```{r, message=FALSE, echo=FALSE}
sjPlot::tab_model(fit2, show.se = TRUE, string.se = "S.E.",
                  dv.labels = c("OLS"), string.pred = "Variables", 
                  string.ci = "C.I. (95%)", p.style = "stars", 
                  file = "output.html")
        ```

        ```{r, message=F}
test$y_hat <- predict(fit, newdata = data.frame(x1 = test$x1))
MSE_ols <- sum((test$y - test$y_hat)^2)/nrow(test)

MSE_ols
        ```

      - Step 3: Run KNN and Compute the MSE
    
        ```{r, message=F, warning=F, error=F}
train_no_y <- train %>% select(x1) 
test_no_y <- test %>% select(x1) 
train_y <- train %>% select(y) 
        ```

        ```{r, message=F, warning=F, error=F}
MSE_KNN <- c()

for (i in seq(1, 100, by = 2)){
  yhat_k <- knn.reg(train = train_no_y, test = test_no_y, y = train_y, k = i)
  MSE_k <- sum((test$y - yhat_k$pred)^2)/nrow(test)
  MSE_KNN <- c(MSE_KNN, MSE_k)
}

MSE_KNN
        ```

      - Step 4: Compare the MSE obtained from OLS and with that from KNN
    
        ```{r, message=F, fig.align='center', fig.width=5, fig.height=4}
ggplot(data = data.frame(K = seq(1, 100, by = 2), MSE = MSE_KNN), 
       aes(y = MSE, x = K)) +
  geom_line(alpha = 0.4, color = "darkgreen") +
  geom_point(alpha = 0.3, color = "darkgreen") +
  geom_hline(yintercept = MSE_ols, color = "darkgray", 
             alpha = 0.8, linetype = "dashed") +
  annotate("text", x = 90, y = 4e+13, label = "KNN", color = "darkgreen", alpha = 0.5) +
  annotate("text", x = 90, y = 3.7e+13, label = "OLS", color = "darkgray") +
  theme_bw()
        ```   

        As observed, regardless of the choice of $K$ in our KNN regression, the MSE obtained from KNN is consistently much smaller than that from OLS.

4. **Curse of Dimensionality**: When dealing with high-dimensional data (i.e., when you have a lot of predictors), KNN regression may suffer from the “curse of dimensionality.” In such cases, the performance of KNN deteriorates significantly as the dimensionality of the data increases. In the case of KNN regression, as the number of dimensions increases, the distance between data points becomes less meaningful. This is because in high-dimensional spaces, the concept of distance becomes less discriminating, as most data points are located far apart from each other. Consequently, KNN may struggle to find relevant neighbors, leading to poor predictive performance and increased computational complexity. On the other had, linear regression, with its fewer parameters, is less affected by this issue.

    <center>
    ![](/Users/yu-shiuanhuang/Desktop/method-sequence/figures/curse_dimensionality.png){width=60%}
    </center>

    Even in problems in which the dimension is small, we might prefer linear regression to KNN from an interpretability standpoint. If the test MSE of KNN is only slightly lower than that of linear regression, we might be willing to forego a little bit of prediction accuracy for the sake of a simple model that can be described in terms of just a few coefficients, and for which p-values are available.

### 2. Simple Linear Regression

Below is a population regression line equation, assuming that we are the god and know the data-generating process of the relationship between $X$ (independent/explanatory variable) and $Y$ (dependent/response/outcome variable).

<center>![](https://miro.medium.com/max/1400/1*tZaCUZ2YuhIQfQmm5ltPEw.webp){width="60%"}</center>

However, since we usually don't have the population data but only have access to a sample of it, we can only use the sample dataset to estimate the population regression line. In the below figure, $b_0$ is the estimate of the regression intercept $\beta_0$, while $b_1$ is the estimate of the regression coefficient/slope $\beta_1$.

<center>![](https://miro.medium.com/v2/format:webp/1*csk8XTXy0j__hm_kbkwxCw.jpeg){width="60%"} </center>

The Ordinary Least Squares (OLS) approach aims to fit a line that minimizes the sum of the squared residuals, which means that the goal is to find a pair of $b_0$ and $b_1$ that can minimize the difference between our observed $Y_i$ and estimated $\hat{Y_i}$.

$$S(A, B) = min \Sigma E_i = min \Sigma (Y_i-\hat{Y_i})^2=min \Sigma (Y_i-(A+BX_i))^2$$

$$S(A, B) = \Sigma (Y_i-A-BX_i)^2$$


To find a pair of $b_0$ and $b_1$ that can minimize the difference between our observed $Y_i$ and estimated $\hat{Y_i}$ is an *optimization problem*. All we have to do is to take the partial derivatives of the above equation with respect to $b_0$ and $b_1$, respectively, set them equal to zero, and then solve it.


$$\frac{\partial S(A, B)}{\partial A}=\Sigma (-1)(2)(Y_i-A-BX_i)=0$$

$$\frac{\partial S(A, B)}{\partial B}=\Sigma (-X_i)(2)(Y_i-A-BX_i)=0$$

By solving the above two equations, you will get:

$$A = \bar{Y}-B\bar{X}$$

$$B = \frac{\Sigma (X_i-\bar{X})(Y_i-\bar{Y})}{\Sigma (X_i-\bar{X})^2}$$

#### a. Gauss-Markov Theorem

Gauss Markov theorem states that "if the errors are independently distributed with zero expectation and constant variance, then the least-squares estimator **b** is the most efficient linear unbiased estimator of $\beta$. That is, of all unbiased estimators that are linear functions of the observations, the least-squares estimator has the smallest sampling variance and, hence, the smallest mean-squared error. For this reason, the least-squares estimator is sometimes termed BLUE, an acronym for best linear unbiased estimator" (Fox 2016: 212).

In other words, under certain conditions, the ordinary least squares (OLS) estimates are thought to be the **best linear unbiased estimator (BLUE)**. Here, I review a set of assumptions (known as Gauss-Markov assumptions) that leads to a BLUE estimator.

1. Linearity: the expected (mean) value of the disturbance term is 0 (i.e., $E(u_i)=0$).

    Fox (2016) explains that a violation of this assumption implies "that the model fails to capture the systematic pattern of relationship between the response and explanatory variables" (307). This assumption could be broken in two ways: one, the mean of error could be a constant across all values of $X_i$, two, it could vary. In the former case, the intercept term will be consistently off by the error amount. A uniform measurement error across all observations would be a cause of such an error (Berry 1993: 42). A common cause of the latter case will be **omitted variable bias**. Omitted variable bias deserves particular attention because it can cause the OLS estimate to be both biased and inconsistent. Another common cause is the wrong functional form (e.g., specifying a linear relation instead of a quadratic relation). Thus, when nonlinearity is detected, we should explore not only variable transformations and different model specifications (Fox, 2016: 317), but also the possibility of omitted variables. In short, before running OLS, reseachers should make sure that the inclusion of relevant variables in the model and the setting of the function are resonable and are based on the theoretical understanding.

2. Nonstochastic regressors: $X$ values are independent of the error term (i.e., $cov(X_i, u_i)=0$).

    The violation of this assumption suggests that there is an **endogeneity** problem between the explanatory and outcome variables, which can arise from measurement error on $X$, omitted confounders, or reciprocal causation between $X$ and $Y$. Again, if the main goal of the research is to provide an unbiased and consistent estimator to explain how a social phenomenon works in a real-life setting, to provide a convincing explanation requires us to make sure that the effect of our explanatory variable is actually exogenous.Fortunately, scholars have developed many methods to address this issue. For example, researchers could employ an instrumental variable or matching to improve the unbiasedness of the estimated effect.

3. Homoskedasticity: constant error variance across values of $X_i$ (i.e., $Var(\varepsilon)=\sigma^2$).

    One instance where heteroskedasticity is often violated is cross-sectional studies (Berry, 1993: 73). For example, because more developed countries can have better data accuracy, measurement error could be correlated with the level of development. Thus, in a study that includes the level of development as one of the independent variables, the variance of error term may not be constant (Berry, 1993: 73). In such circumstances, Fox (2016) suggests that we can run weighted-least-squares (WLS) regression to overcome such probelm (304). Other solutions include transformation of the dependent variable and correction of coefficient standard errors (e.g. robust standard errors and clustered standard errors) for heteroskedasticity (Fox, 2016: 307).

4. Independence: the observations are sampled independently. no autocorrelation between disturbances (i.e., $cov(u_i, u_j)=0$ for $i \neq j$).

    The independence assumption is important for time-series analysis, where the assumption of spherical errors is often violated. To overcome this, Beck & Katz (1995) propose panel-correlated standard errors to when analyzing time-series data.

5.  Normality: errors are distributed normally (i.e.,$\varepsilon \sim N(0, \sigma^2)$).

Assumptions of 1 and 2 are related to the bias of the estimator, whereas assumptions of 3 and 4 are related to the efficiency of the estimator: when the assumption of 1 or 2 is violated, the OLS estimator is no longer unbiased; when the assumption of 3 or 4 is violated, the OLS estimator is no longer efficient. With these weak set of assumptions (1-4), according to the Gauss-Markov theorem, the OLS estimator is BLUE.

(In statistics, efficiency is a measure of the quality of an estimator, which can be characterized by having a smaller possible variance.)

With the fifth assumption, normality, the OLS estimator is the most efficient among all the unbiased estimators, not just linear estimators. Adding this fifth assumption makes the Gauss-Markov theorem a strong set. This last assumption is important when we aim to make a causal inference using the OLS estimator. With the normal distribution of the errors assumption, we can also infer that the OLS estimators also have normal sampling distributions. As a result, it allows us to apply statistical tests such as t-tests even for small sample size studies.

One important caveat is that when there is perfect multicollinearity (i.e. when two or more independent variables are perfectly correlated), we cannot even get an estimate using the OLS method. However, even when there is high multicollinearity, the OLS estimate is still BLUE (Berry 1993: 27). In such cases, standard errors will be very high, making the estimates fluctuate considerably from sample to sample (Berry 1993: 27).

The below table presents the consequences of the violation of Gauss-Markov assumptions and corresponded suggested solutions.

| Assumption               | Violation                     | Solution                                      |
|-------------------|----------------------|-------------------------------|
| Linearity                | Biased/inconsistent estimates | Transformations, polynomials, different model |
| Nonstochastic regressors | Biased/inconsistent estimates | Instrumental variables                        |
| Homoskedasticity         | Biased standard errors        | Robust standard errors                        |
| Independence             | Biased standard errors        | Fixed effects                                 |
| Perfect collinearity     | cannot run OLS                | Omit one collinear term                       |

#### b. Properties of Least Squares Estimator

The sample least squares coefficients are unbiased estimators of the population regression coefficients.

Here are some reviews before demonstrating the unbiasedness of the least-squares estimators $A$ and $B$ for $\alpha$ and $\beta$:

- The assumed model: $Y_i=\alpha+\beta X_i+\varepsilon_i$
- Linearity assumption: $E(\varepsilon_i)=0$
- Normality assumption: $\varepsilon_i\sim N(0, \sigma_\varepsilon^2)$
- Independence assumption: $Cov(\varepsilon_i, \varepsilon_j)=0,  for i\neq j$
- The expectation of linear combination: $E(a+bY)=a+bE(Y)$
- The variance of linear combination: 
    - $Var(a+bY)=b^2Var(Y)$
    - $Var(X+Y)=Var(X)+Var(Y)+2Cov(X, Y)$
- For the below demonstration, the $X_i$ are assumed to be fixed, not random.
    - $B=\frac{\Sigma(X_i-\bar{X})(Y_i-\bar{Y})}{\Sigma(X_i-\bar{X})^2}=\frac{\Sigma(X_i-\bar{X})Y_i-\Sigma(X_i-\bar{X})\bar{Y}}{\Sigma(X_i-\bar{X})^2}=\frac{\Sigma(X_i-\bar{X})Y_i-\bar{Y}\Sigma(X_i-\bar{X})}{\Sigma(X_i-\bar{X})^2}=\frac{\Sigma(X_i-\bar{X})Y_i}{\Sigma(X_i-\bar{X})^2}$
    - $\Sigma(X_i-\bar{X})^2=\Sigma(X_i-\bar{X})(X_i-\bar{X})=\Sigma X_i(X_i-\bar{X})-\bar{X}\Sigma(X_i-\bar{X})=\Sigma X_i(X_i-\bar{X})$ 

1. Demonstrate the unbiasedness of the least-squares estimators $B$ for $\beta$ in simple regression (i.e., $E(B) = \beta$).

    $E(B)=\frac{\Sigma(X_i-\bar{X})(Y_i-\bar{Y})}{\Sigma(X_i-\bar{X})^2}$
    
    $=\frac{\Sigma(X_i-\bar{X})Y_i}{\Sigma(X_i-\bar{X})^2}$
    
    $=\frac{1}{\Sigma(X_i-\bar{X})^2}E(\Sigma(X_i-\bar{X})Y_i)$
    
    $=\frac{1}{\Sigma(X_i-\bar{X})^2}\Sigma(X_i-\bar{X})E(Y_i)$
    
    $=\frac{1}{\Sigma(X_i-\bar{X})^2}\Sigma(X_i-\bar{X})E(\alpha + \beta X_i+\varepsilon_i)$
    
    $=\frac{1}{\Sigma(X_i-\bar{X})^2}\Sigma(X_i-\bar{X})(\alpha +\beta X_i+E(\varepsilon_i))$
    
    $=\frac{1}{\Sigma(X_i-\bar{X})^2}\Sigma(X_i-\bar{X})(\alpha+\beta X_i)$
    
    $=\frac{1}{\Sigma(X_i-\bar{X})^2}(\Sigma(X_i-\bar{X})\alpha+\Sigma(X_i-\bar{X})\beta X_i)$
    
    $=\frac{\beta}{\Sigma(X_i-\bar{X})^2}(\Sigma(X_i-\bar{X})X_i)$
    
    $=\beta$

2. Demonstrate the unbiasedness of the least-squares estimators $A$ for $\alpha$ in simple regression (i.e., $E(A) = \alpha$).

    $E(A)=E(\bar{Y}-B\bar{X})$
    
    $=E(\frac{1}{n}\Sigma Y_i-\frac{\Sigma(X_i-\bar{X})(Y_i-\bar{Y})}{\Sigma(X_i-\bar{X})^2}\bar{X})$
    
    $=E(\frac{1}{n}\Sigma Y_i-\frac{\Sigma(X_i-\bar{X})Y_i}{\Sigma(X_i-\bar{X})^2}\bar{X})$
    
    $=E(\Sigma(\frac{1}{n}-\frac{\bar{X}(X_i-\bar{X})}{\Sigma(X_i-\bar{X})^2})Y_i)$
    
    $=E(\Sigma(\frac{1}{n}-\frac{\bar{X}(X_i-\bar{X})}{\Sigma(X_i-\bar{X})^2})(\alpha +\beta X_i +\varepsilon_i))$
    
    $=E(\Sigma(\frac{1}{n}-\frac{\bar{X}(X_i-\bar{X})}{\Sigma(X_i-\bar{X})^2}))E(\alpha +\beta X_i +\varepsilon_i)$
    
    $=E(\Sigma(\frac{1}{n}-\frac{\bar{X}(X_i-\bar{X})}{\Sigma(X_i-\bar{X})^2}))(\alpha+\beta X_i+E(\varepsilon_i))$
    
    $=\Sigma(\frac{1}{n}-\frac{\bar{X}(X_i-\bar{X})}{\Sigma(X_i-\bar{X})^2})(\alpha+\beta X_i)$
    
    $=\Sigma \frac{\alpha}{n}+\Sigma \beta \frac{X_i}{n}-\alpha \frac{\bar{X}\Sigma(X_i-\bar{X})}{\Sigma(X_i-\bar{X})^2}-\beta \frac{\bar{X}\Sigma(X_i-\bar{X})X_i}{\Sigma(X_i-\bar{X})^2}$
    
    $=\alpha + \beta \bar{X}-\alpha*0-\beta \bar{X}$
    
    $=\alpha$
    
3. Derive the sampling variances of $A$ in a simple regression.

    $Var(B)=Var(\frac{\Sigma(X_i-\bar{X})Y_i}{\Sigma(X_i-\bar{X})^2})$
    
    $=\frac{1}{(\Sigma(X_i-\bar{X})^2)^2}Var(\Sigma(X_i-\bar{X})Y_i)$
    
    $=\frac{1}{(\Sigma(X_i-\bar{X})^2)^2}Var(\Sigma(X_i-\bar{X})(\alpha + \beta X_i+\varepsilon_i))$
    
    $=\frac{1}{(\Sigma(X_i-\bar{X})^2)^2}Var(\Sigma(X_i-\bar{X}(\alpha + \beta X_i)+\Sigma(X_i-\bar{X})\varepsilon_i)$
    
    $=\frac{1}{(\Sigma(X_i-\bar{X})^2)^2}Var(\Sigma(X_i-\bar{X})\varepsilon_i)=\frac{1}{(\Sigma(X_i-\bar{X})^2)^2}\Sigma Var((X_i-\bar{X})\varepsilon_i)$
    
    $=\frac{1}{(\Sigma(X_i-\bar{X})^2)^2}(\Sigma (X_i-\bar{X})^2 Var(\varepsilon_i))$
    
    $=\frac{1}{(\Sigma(X_i-\bar{X})^2)^2}(\Sigma (X_i-\bar{X})^2 \sigma_\varepsilon^2)$
    
    $=\frac{\sigma_\varepsilon^2}{\Sigma(X_i-\bar{X})^2}$

4. Derive the sampling variances of $B$ in a simple regression.

    $Var(A)=Var(\bar{Y}-B\bar{X})$
    
    $=Var(\bar{Y})+Var(B\bar{X})-2Cov(\bar{Y},B\bar{X})$
    
    $=Var(\bar{Y})+Var(B\bar{X})$
    
    $=Var(\frac{\Sigma Y_i}{n})+\bar{X}^2Var(B)$
    
    $=\frac{1}{n^2}Var(\Sigma Y_i)+\bar{X}^2Var(B)$
    
    $=\frac{1}{n^2}\Sigma Var(Y_i)+\bar{X}^2Var(B)$
    
    $=\frac{1}{n^2}\Sigma Var(\alpha+\beta X_i+\varepsilon_i)+\bar{X}^2Var(B)$
    
    $=\frac{1}{n^2}\Sigma Var(\varepsilon_i)+\bar{X}^2Var(B)$
    
    $=\frac{1}{n^2}n\sigma_\varepsilon^2+\bar{X}(\frac{\sigma_\varepsilon^2}{\Sigma(X_i-\bar{X})^2})$
    
    $=\sigma_\varepsilon^2(\frac{1}{n}+\frac{\bar{X}^2}{\Sigma(X_i-\bar{X})^2})$
    
    $=\sigma_\varepsilon^2(\frac{\Sigma(X_i-\bar{X})^2 +n\bar{X}^2}{n\Sigma(X_i-\bar{X})^2})$
    
    $=\sigma_\varepsilon^2(\frac{\Sigma X_i^2-2\bar{X}\Sigma X_i+\Sigma \bar{X}^2+n\bar{X}^2}{n\Sigma(X_i-\bar{X})^2})$
    
    $=\sigma_\varepsilon^2(\frac{\Sigma X_i^2-2\bar{X}\Sigma X_i+2n \bar{X}^2}{n\Sigma(X_i-\bar{X})^2})$
    
    $=\sigma_\varepsilon^2(\frac{\Sigma X_i^2-2\frac{\Sigma X_i}{n}\Sigma X_i+2n \bar{X}^2}{n\Sigma(X_i-\bar{X})^2})$
    
    $=\sigma_\varepsilon^2(\frac{\Sigma X_i^2-\frac{2\Sigma X_i^2}{n}+2n\frac{\Sigma X_i^2}{n^2}}{n\Sigma(X_i-\bar{X})^2})$
    
    $=\frac{\sigma_\varepsilon^2 \Sigma X_i^2}{n\Sigma(X_i-\bar{X})^2}$

#### c. Confidence Interval & Hypothesis Testing

As mentioned earlier, the fifth assumption, normality, allows us to apply statistical inference tests to assess the $\beta$s we estimate. Recall from the lecture that the residual standard error $S_E$ (how closely the regression line we estimate fits the scatter of our data points) is:

$$\hat{\sigma } = SE(E_i) = \sqrt{\frac{\Sigma (E_i)^2}{n-2}} = \sqrt{\frac{\Sigma (Y_i-\hat{Y_i})^2}{n-2}}$$

And the standard error of the sample intercept ($A$) and slope ($B$) are:

$$SE(A) = \hat{\sigma }\sqrt{\frac{\Sigma X_i^2}{n\Sigma (X_i-\bar{X})^2}}$$

$$SE(B) = \frac{\hat{\sigma }}{\sqrt{\Sigma (X_i-\bar{X})^2}}$$

With standard errors, we can construct a $100(1-\alpha)%$ confidence interval for our slope and perform hypothesis testing.

-   Confidence Interval

    $\beta=B+t_{\frac{\alpha}{2}}SE(B)$

-   Hypothesis Test

    Two-tailed test (by defualt, `lm()`function conducts two-tailedtest)

    $H_0: \beta = 0$

    $H_1: \beta \neq 0$

    $t=\frac{b_1-\beta_1}{SE(b_1)}=\frac{b_1-0}{SE(b_1)}$

    Compare this t-statistic with $t_{\frac{\alpha}{2}, df=n-2}$ to see if it is larger or smaller than the critical value or not. If it is larger or smaller than the critical value, we can reject $H_0$ in favor of $H_1$. In addition to calculating t-statistics, we can also calculate p-value based the t-statistics and the critical values to perform hypothesis testing (p-value $= 2*Pr(t \geq |t_c|)$ vs $\alpha$).

    One-tailed test (if your hypotheses are directional, you can also conduct one-tailed test)

    $H_0: \beta = 0$

    $H_1: \beta < or > 0$

    $t=\frac{B-\beta_1}{SE(B)}=\frac{B-0}{SE(B)}$

    When performing a one-tailed test, compare the t-statistic with $t_{\alpha, df=n-2}$ without dividing $\alpha$ by 2. P-value in one-tailed test is calculated as:

    p-value $= Pr(t \geq or \leq t_c)$ vs $\alpha$

    Let's run a simple example of it using the `prestige` data from Problem Set 1. The `prestige` data consists of 10 observations with 2 variables. The description of the variables are as follows:
    
    - `prestige`:The average prestige rating for the occupation.
    
    - `education`: The average number of years of education for occupational incumbents.
    

    ```{r, message=FALSE}
    # load data
    df <- read.csv("/Users/yu-shiuanhuang/Desktop/method-sequence/data/ps1_prestige.csv") 
    df
    ```

    Let's first calculate all the statistics we'll need to perform hypothesis testing.

    1. Slope: $B$

        $B=\frac{\Sigma(X_i-\bar{X})(Y_i-\bar{Y})}{\Sigma(X_i-\bar{X})^2}$

    ```{r, message=FALSE}
    # calculate the slope b1
    B <- sum((df$education-mean(df$education))*(df$prestige-mean(df$prestige)))/
    sum((df$education-mean(df$education))^2)
    B
    ```

    2. Intercept: $A$

        $A=\bar{Y}-B\bar{X}$

    ```{r, message=FALSE}
    # calculate the intercept b0
    A <- mean(df$prestige)-B*mean(df$education)
    A
    ```

    3. Residual Standard Error: $\hat{\sigma} = SE(E_i)$

        $\hat{\sigma } = SE(E_i) = \sqrt{\frac{\Sigma (E_i)^2}{n-2}} = \sqrt{\frac{\Sigma (Y_i-\hat{Y_i})^2}{n-2}}$

    ```{r, message=FALSE}
    # generate predicted Y
    df$pred <- A + B*df$education

    #calculate the residual standard error 
    se <- sqrt(sum((df$prestige-df$pred)^2)/(nrow(df)-2))
    se
    ```

    4. Standard Error of the Estimated Intercept and Slope: $SE(A)$ & $SE(B)$

        $SE(A) = \hat{\sigma }\sqrt{\frac{\Sigma X_i^2}{n\Sigma (X_i-\bar{X})^2}}$

        $SE(B) = \frac{\hat{\sigma }}{\sqrt{\Sigma (X_i-\bar{X})^2}}$

    ```{r, message=FALSE}
    # calculate the standard error of the estimated intercept b0
    se_A <- se*sqrt(sum(df$education^2)/(nrow(df)*sum((df$education-mean(df$education))^2)))
    se_A
    ```

    ```{r, message=FALSE}
    # calculate the standard error of the estimated slope b1
    se_B <- se/sqrt(sum((df$education-mean(df$education))^2))
    se_B
    ```

    Now, let's perform two-tailed hypothesis testing of the slope.

    $H_0: \beta = 0$

    $H_1: \beta \neq 0$

    $t=\frac{B-\beta_1}{SE(B)}=\frac{B-0}{SE(B)}=\frac{0.3895028-0}{0.6554015}=0.5942964$

    ```{r, message=FALSE}
    # calculate the t-statistic
    t <- B/se_B
    t
    ```

    What are the t critical values in both tails? Let's say the level of significance, $\alpha$, is 0.05 in this case.

    $|t_{\frac{\alpha}{2}, df=n-2}|=|t_{\frac{0.05}{2}, df=10-2}|=2.306004$

    ```{r, message=FALSE}
    # find t critical value
    qt(p = 0.025, df = 8, lower.tail = TRUE)
    qt(p = 0.025, df = 8, lower.tail = FALSE)
    ```

    Now, let's compare our t-statistic of $b_1$ with the t critical value.

    $t=0.5942964 < |t_{\frac{0.05}{2}, df=8}|=2.306004$

    We can also calculate the p-value.

    p-value $= 2*Pr(t \geq 0.5942964)=0.5687352 > 0.05$

    ```{r, message=FALSE}
    # find p-value
    2*pt(q = 0.5942964, df = 8, lower.tail = FALSE)
    ```

    These all suggest that we cannot reject $H_0$, which means that the positive effect of *education* on one's *prestige* is not statistically significant.

    Let's also try perform one-tailed hypothesis testing for this case.

    $H_0: \beta = 0$

    $H_1: \beta > 0$

    $t=\frac{B-\beta_1}{SE(b_1)}=\frac{B-0}{SE(B)}=\frac{0.3895028-0}{0.6554015}=0.5942964$

    What is the t critical values in the right tail?

    $t_{\alpha, df=n-2}=t_{0.05, df=10-2}=1.859548$

    ```{r, message=FALSE}
    # find t critical value
    qt(p = 0.05, df = 8, lower.tail = FALSE)
    ```

    Now again, let's compare our t-statistic of $B$ with the t critical value.

    $t=0.5942964 < t_{0.05, df=8}=1.859548$

    And the p-value in the one-tailed test is:

    p-value $=Pr(t \geq 0.5942964)= 0.2843676 > 0.05$

    ```{r, message=FALSE}
    # find p-value
    pt(q = 0.5942964, df = 8, lower.tail = FALSE)
    ```

    In R, `lm()` does all the above calculation for us!

    ```{r, message=FALSE, warning=FALSE}
    # simple regression
    fit <- lm(prestige ~ education, data = df)
    summary(fit)
    ```

#### d. Evaluating Least Squares Fit

We understand that there will be variability in the variable `prestige` across different occupations, with some having high prestige and others having low prestige. Some of this variability can be attributed to factors not included as variables in our regression model, such as economic conditions and other unmeasured variables. Additionally, differences in the variable `education` may explain some of the differences in `prestige` across occupations. For instance, occupations with a higher average number of years of education among incumbents tend to have higher prestige. However, it's important to quantify how much of the variability in `prestige` can be explained by the variables included in our regression model, and how much remains unexplained by other factors that we have not accounted for.

<center>
![](/Users/yu-shiuanhuang/Desktop/method-sequence/figures/variance_decom.png){width=60%}
</center>

1.  Explained Variability: Regression Sum of Squares (RegSS)

    The Regression Sum of Squares (RegSS) (sometimes referred to as the Sum of Squares Explained, SSE) is a measure of the variability in the outcome variable that is explained by the explanatory variables, i.e. the x-variables in your regression. It is given by the following sum:

    $RegSS = \sum_{i=1}^{n}(\hat{y_i}-\bar{y})^2$


2. Residual or Unexplained Variability: Residual Sum of Squares (RSS)

    The Residual Sum of Squares (RSS) is a measure of the variability in the outcome variable that is not explained by your regression, and therefore is due to all the other factors that affect `prestige` besides `education`. It is given by the following sum:
    
    $RSS = \sum_{i=1}^{n}(y_i-\hat{y_i})^2 = \sum_{i=1}^{n}e_i^2$

3. Total Variability: Total Sum of Squares (TSS)

    You can show mathematically that $RSS + RegSS$ is equal to the following expression, which is referred to as the Total Sum of Squares (TSS):

    $TSS = \sum_{i=1}^{n}(y_i-\bar{y_i})^2 = \sum_{i=1}^{n}(y_i-\hat{y_i})^2 + \sum_{i=1}^{n}(\hat{y_i}-\bar{y})^2 = RSS + RegSS$

4. Coefficient of Determination: R-Squared value

    The coefficient of determination, sometimes referred to as the R-Squared value, is a measure of what percentage of the variability in your outcome variable is explained by your explanatory variables. It is given by the expression,

    $R^2 = \frac{RegSS}{TSS}$
    
## Discussion II

For today's discussion, we will review concepts regarding how to find a set of $\hat{\beta}$s that can minimize the squared residual errors of our multivariate linear model using matrix algebra.

1. Multivariate Linear Regression
2. Find Coefficients using Matrix in R

### 1. Multivariate Linear Regression

The central difference between simple and multiple linear regression is that the slope coefficients for the explanatory variables in multiple regression are **partial coefficients**. That is, it represents the "effect" on the response variable of a one-unit increment in the corresponding explanatory variable, holding constant the value of the other explanatory variable. 

$$Y_i=\hat{\beta_0}+\hat{\beta_1}X_{i1}+\hat{\beta_2}X_{i2}+...+\hat{\beta_k}X_{ik}+\varepsilon_i$$

Recall that the goal of the OLS approach is to minimize the discrepancy between our observed $Y_i$ and estimated $\hat{Y_i}$. To find a set of estimated $\beta$s that can minimize this discrepancy is an *optimization problem*. All we have to do is to take the partial derivatives of the above equation with respect to each coefficient, set them equal to zero, and then solve it. However, as shown in the lecture, adding more and more $X$ variables to our linear regression model makes the calculation more and more tedious. In order to find the estimated $\beta$s more efficiently, we use matrix algebra to help us do the calculation.

To do this, let's first think of our data set as a matrix. The below equations are how each observation in our data set generated.

$$Y_1=\hat{\beta_0}+\hat{\beta_1}X_{11}+\hat{\beta_2}X_{12}+...+\hat{\beta_k}X_{1k}+\varepsilon_1$$

$$Y_2=\hat{\beta_0}+\hat{\beta_1}X_{21}+\hat{\beta_2}X_{22}+...+\hat{\beta_k}X_{2k}+\varepsilon_2$$

.

.

.

$$Y_n=\hat{\beta_0}+\hat{\beta_1}X_{n1}+\hat{\beta_2}X_{n2}+...+\hat{\beta_k}X_{nk}+\varepsilon_n$$


Rewrite them into a matrix form.

<center>![](/Users/yu-shiuanhuang/Desktop/method-sequence/figures/matrix.png){width="50%"}</center>

The system of equations is summarized as the *y* vector equal to the product of the *X* matrix of data times the *$\hat{\beta}$* vector of parameters plus the vector of disturbances, $\varepsilon$. That said, the fitted linear model we are trying to find is: $y = X\hat{\beta}+\varepsilon$. In the lecture, Lauren showed how to apply what we did when finding a pair of intercept and slope in simple linear regression to solve the **optimization problem**(i.e., minimize RSS) to find the coefficient vector $\hat{\beta}$ using matrix algebra.  

$$
\begin{aligned}
S(\hat{\beta}) &= \sum E_i^2 = \varepsilon\varepsilon' = (y- X\hat{\beta})'(y- X\hat{\beta})\\
&= y'y-y'X\hat{\beta}-\hat{\beta}'X'y+\hat{\beta}'X'X\hat{\beta} \\
&= y'y-(2y'X)\hat{\beta}+\hat{\beta}'(X'X)\hat{\beta}
\end{aligned}
$$

Instead of taking derivative with respect to each coefficient one at a time, we can take derivative directly with respect to the coefficient vector $\hat{\beta}$.

$$
\begin{aligned}
S(\hat{\beta}) &= \sum E_i^2 = \varepsilon\varepsilon' = (y- X\hat{\beta})(y- X\hat{\beta})'\\
&= y'y-y'X\hat{\beta}-\hat{\beta}'X'y+\hat{\beta}'X'X\hat{\beta} \\
&= y'y-(2y'X)\hat{\beta}+\hat{\beta}'(X'X)\hat{\beta}
\end{aligned}
$$
$$
\begin{aligned}
\partial S(\hat{\beta}) &= \frac{\partial}{\partial \hat{\beta}}(y'y-(2y'X)\hat{\beta}+\hat{\beta}'(X'X)\hat{\beta}) \\
0 &=0-2Xy'+ 2\hat{\beta}X'X \\
2\hat{\beta}X'X &=2Xy'\\
\hat{\beta} &= \frac{Xy'}{X'X} \\
\hat{\beta} &= (X'X)^{-1}Xy'
\end{aligned}
$$
Therefore, the least squares estimator is:

$$\hat{\beta}=(X'X)^{-1}X'y$$

### 2. Find Coefficients using Matrix in R

Let's use the `Anscombe.txt` data set as an example to find the estimated coefficients by using the above matrix equation.

- `education` = per capita education expenditures, dollars
- `income` = per capita income, dollars
- `under18` = proportion under 18 years old, per 1000
- `urban` = proportion urban, per 1000

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
# load data
df2 <- read.delim("/Users/yu-shiuanhuang/Desktop/method-sequence/data/Anscombe.txt", sep = "")
head(df2)
```

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
# convert each variable to a vector
edu <- df2$education
intercept <- rep(1, nrow(df2)) # remember to crease this vector with 1s!
inc <- df2$income
un18 <- df2$under18
urb <- df2$urban
X <- cbind(intercept, inc, un18, urb)
class(X) # this is a matrix
```

We now have a vector `edu` and a matrix $X$ containing our intercepts and our three explanatory variables (`income`, `under18`, `urban`). Let's estimate our best fit parameters $\beta_0, \beta_1,$, $\beta_2$, and $\beta_3$ by applying the estimator we derived in the lecture: $\hat{\beta} = (X'X)^{-1}X'y$.

```{r, results = 'show', message = FALSE}
beta.hat <- solve(t(X) %*% X) %*% t(X) %*% edu

t(beta.hat)
```

Compare with the canned routine in R to confirm the matrix calculation was correct. 

```{r, results = 'show', message = FALSE}
mod <- lm(edu ~ X-1) # remember to remove the first column in the X matrix bc that's the column with all the 1s we created just for the algebra calculation

beta.canned <- mod$coefficients
beta.canned
```

How to come up with the predicted $\hat{y}$?
$$\hat{y}=Xb$$
        
```{r, results = 'show', message = FALSE}
eduhat <- beta.hat[1] + df2$income*beta.hat[2] + 
    df2$under18*beta.hat[3] + df2$urban*beta.hat[4]
eduhat
```

How to come up with the residuals?
$$e=y-\hat{y}=y-Xb$$
```{r, results = 'show', message = FALSE}
e <- edu - eduhat
e
```

Now calculate the standard errors of the vector *$\hat{\beta}$*. Recall the error variance is unknown but we have available the unbiased estimator $S^2_E = (e'e)/(n-k-1)$, based on the residuals of our model fit. We can extract these residuals, calculate the estimator, and then use it to calculate the variance of the least squares coefficients $\hat{V(b)} = S^2_E (X'X)^{-1}$. 

- As a quick refresher of concepts: the variance is a measure of a random variable’s “spread” or variation around its mean (a.k.a. its expected value), while the co-variance measures how correlated are the variations of two random variables with each other.

- The *variance-covariance matrix* is a square matrix (i.e. it has the same number of rows and columns). The elements of the matrix that lie along its main diagonal (i.e. the one that goes from top-left to bottom-right contain the variances while all other elements contain the co-variances). Thus, the variance-covariance matrix of the fitted coefficients of a regression model contains the variances of the fitted model’s coefficient estimates along its main diagonal, and it also contains the pair-wise co-variances between coefficient estimates in the non-diagonal elements.

- Why do we not only calculate the variance of regression coefficients but also the convariance of them?
    
    The covariance matrix can be very useful for certain model diagnostics. If two variables are highly correlated, one way to think about it is that the model is having trouble figuring out which variable is responsible for an effect (because they are so closely related). This can be helpful for a whole variety of cases, such as choosing subsets of covariates to use in a predictive model; if two variables are highly correlated, you may only want to use one of the two in your predictive model.

```{r, results = 'show', message = FALSE}
S2E <- as.numeric((t(e)%*%e)/(nrow(df2)-3-1))
S2E

v.beta.hat <- S2E*solve(t(X)%*%X)
v.beta.hat # the diagonal numbers are the variance of each coefficient

sqrt(diag(v.beta.hat)) 
```

Compare with the canned routine in R to see if we got the same standard errors of coefficients.

```{r, message=FALSE, echo=FALSE}
sjPlot::tab_model(mod, show.se = TRUE, string.se = "S.E.",
                  dv.labels = c("OLS"), string.pred = "Variables", 
                  string.ci = "C.I. (95%)", p.style = "stars", 
                  file = "output.html")
```

With the standard errors of each coefficient, we can perform hypothesis testing and construct confidence intervals to determine the significance and reliability of the estimated effects (similar to what we did in the case of simple linear regression).

- What would happen when there is *perfect multicollinearity* in our data (i.e. when two or more independent variables are perfectly correlated)?

    ```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
# convert each variable to a vector
edu <- df2$education
intercept <- rep(1, nrow(df2)) # remember to crease this vector with 1s!
inc <- df2$income
un18 <- df2$under18
urb <- df2$urban
pmc <- 2*inc
cor(pmc, inc) # pmc is perfectly correlated with inc
X <- cbind(intercept, inc, un18, urb, pmc)
class(X) # this is a matrix
    ```

    ```{r, results = 'show', message = TRUE, error=TRUE}
beta.hat <- solve(t(X) %*% X) %*% t(X) %*% edu
```

    As you can see in the result of the above chunk, you cannot calculate the matrix algebra when there is perfect multicollinearity. However, when you run `lm()` in R, R will automatically delete the variable that is perfectly correlated with the other variable(s) in the dataset.

    ```{r, results = 'show', message = FALSE}
mod2 <- lm(edu ~ X-1) # remember to remove the first column in the X matrix bc that's the column with all the 1s we created just for the algebra calculation
```

    ```{r, message=FALSE, echo=FALSE}
sjPlot::tab_model(mod2, show.se = TRUE, string.se = "S.E.",
                  dv.labels = c("OLS"), string.pred = "Variables", 
                  string.ci = "C.I. (95%)", p.style = "stars", 
                  file = "output.html")
    ```
    
    If there is high multicollinearity between variables but not perfectly correlated, the matrix algebra still works, and `lm()` will still spit out the estimates of the highly correlated variable. However, the standard errors of coefficients will be very high.

    ```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
# convert each variable to a vector
edu <- df2$education
intercept <- rep(1, nrow(df2)) # remember to crease this vector with 1s!
inc <- df2$income
un18 <- df2$under18
urb <- df2$urban
set.seed(1234)
pmc <- 2*inc + rnorm(nrow(df2), 5, 1)
cor(pmc, inc) # pmc is highly but not perfectly correlated with inc
X <- cbind(intercept, inc, un18, urb, pmc)
class(X) # this is a matrix
```

    ```{r, results = 'show', message = TRUE}
beta.hat <- solve(t(X) %*% X) %*% t(X) %*% edu

t(beta.hat)
```

    ```{r, results = 'show', message = FALSE}
eduhat <- beta.hat[1] + df2$income*beta.hat[2] + 
    df2$under18*beta.hat[3] + df2$urban*beta.hat[4] + pmc*beta.hat[5]
e <- edu - eduhat
S2E <- as.numeric((t(e)%*%e)/(nrow(df2)-4-1))
v.beta.hat <- S2E*solve(t(X)%*%X)
sqrt(diag(v.beta.hat))
```

    ```{r, message=FALSE, echo=FALSE}
mod3 <- lm(edu ~ X-1)

sjPlot::tab_model(mod, mod3, show.se = TRUE, string.se = "S.E.",
                  dv.labels = c("OLS"), string.pred = "Variables", 
                  string.ci = "C.I. (95%)", p.style = "stars", 
                  file = "output.html")
    ```

## Discussion III

For today's discussion, we will review some diagnostic techniques to detect influential data points that could affect our model and ensure our model adheres to Gauss-Markov assumptions, addressing any violations as needed.

1.  Unusual and Influential Data
2.  Diagnostics for Errors and Linearity

### 1. Unusual and Influential Data

When dealing with observational or experimental data, it's common to encounter **outliers**, which are data points that behave differently than the rest of the data for some reason. Outliers can greatly influence the analysis and interpretation of the data. In today's discussion, we'll examine what outliers are, how they can affect data analysis and interpretation, and use simple linear regression as an example to explore situations where individual data points significantly impact the model. Lastly, we will also 

#### 1.1 Leverage, discrepancy and influence

Although many researchers discuss outliers in a broad sense, it's important to recognize that there are different types of unusual data points. A data point may be unusual in terms of its predictor behavior (the $x$-value in simple regression), its outcome (the $y$-value in simple regression), or both.

-   **leverage**: A data point that differs significantly from the rest of the dataset in terms of its predictor behavior is known as a leverage point. In the case of simple linear regression, this means that the x-value of the data point is much higher or lower than the mean of the predictor variable.

-   **discrepancy**: When a data point has an uncommon y-value for its corresponding x-value, it is said to have high discrepancy. Within the context of regression analysis, such an unusual point is called an outlier.

-   **influence**: Having either a high leverage or a high discrepancy does not necessarily make a data point influential in a linear model. In fact, a single data point's influence is determined by **leverage × discrepancy**. Therefore, having only high leverage or high discrepancy may not be enough to significantly alter the model parameters.

The figure below illustrates the three characteristics discussed above. In each of the three panels, the red line represents the line of best fit without the data point in question (marked by the triangle), while the blue line shows the line of best fit with it.

-   In panel A, the data point with the triangle has a high leverage - its $x$-value is much higher than the rest.
-   In panel B, it has a high discrepancy - it lies far away from the line of best fit. 

    However, neither of the above characteristics alone exerts a lot of influence on our model parameters, as the red line does not diverge significantly from the blue line.

-   In panel C, we see a data point that has both high leverage and high discrepancy, and as a result, it exerts high influence: the blue line is noticeably different from the red line.

<center>![](https://tillbe.github.io/figure/outlier-influence-identification/unnamed-chunk-2-1.png){width="90%"}</center>

###### Example Data

For today's discussion, we will use a data set based on an example in Field, Miles, and Field (2012). The dataset includes eight samples, where the $x$-value represents the number of pubs within a borough (district) of London, and the $y$-value represents the number of deaths in that borough over a specific period of time. We are interested in investigating the relationship between the number of deaths and the number of pubs in each borough.

```{r, message=FALSE}
pubs <- data.frame(name = c(1, 2, 3, 4, 5, 6, 7, 8), 
                   pubs = c(10, 25, 40, 55, 70, 85, 100, 500), 
                   deaths = c(1043.822, 2086.934, 2951.086, 3992.459, 5088.003, 
                              6095.645, 6923.497, 10000.000))
pubs
```

Let's plot the line of best fit of this data:

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
library(tidyverse)
ggplot(data = pubs, aes(x = pubs, y = deaths, label = name)) +
    geom_point(alpha = 0.8) +
    geom_text(hjust = 2, vjust = 0) +
    geom_smooth(method = lm, se = FALSE, colour = "darkorange") +
    xlab("Number of Pubs") + 
    ylab("Deaths") +
    theme_bw()
```

Both the raw data and the linear regression plot indicate that data point 8 is significantly different from the other samples. This particular data point not only has a much higher number of pubs compared to the others, but it also appears to have a distinct relationship between the number of pubs and the number of deaths, unlike the other boroughs.

Since we have some concerns about this specific data point, let's determine whether it exhibits a) high leverage, b) high discrepancy, and c) high influence.

#### 1.2 Assessing Leverage

Recall that leverage quantifies the degree to which a predictor value differs from the other predictor values. In the case of simple linear regression, we can compute the distance between each predictor point ($X_i$) and the mean predictor value ($\bar{X}$) to measure leverage.

A standardized version of this distance is called *hat-value* and denoted by $h_i$ (for $i = {1,..., n}$):

$$h_i = \frac{1}{n}+\frac{(X_i-\bar{X})^2}{\sum_{j=1}^{n}(X_j-\bar{X})^2}$$

The average hat value ($\bar{h}$) is defined as $\frac{k+1}{n}$, in which $k$ is the number of predictors and $n$ the number of observations. Values of $h$ are bound between $\frac{1}{n}$ and 1, with 1 denoting highest leverage (highest distance from mean).

Based on our sample data, it's obvious that data point 8 has the highest leverage among all the points. Let's apply the formula above to compute the leverage value ($h_8$) for this data point.

```{r, message=FALSE}
# number of cases
n = nrow(pubs)

# distance to mean of point 8
numerator = (pubs$pubs[8] - mean(pubs$pubs))^2

# distance to mean of all the other points
denominator = sum((pubs$pubs - mean(pubs$pubs))^2)

# putting it together
h_8 = 1/n + numerator/denominator

h_8
```

The resulting *hat-value* is 0.969302. This is quite high - in fact, it's very close to 1, the highest possible value.

You don't need to manually calculate all of the hat values because R offers a convenient `hatvalues` function that can be applied to any linear model. To take advantage of this feature, we will begin by fitting a simple linear model using `lm` and then extracting the hat value of each data point.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
# fitting linear model
mod <- lm(deaths ~ pubs, data = pubs)

# getting hatvalues and plotting them
plot(hatvalues(mod))
```

Remember that leverage alone does not mean a point exerts high influence, but it certainly means it's worth investigating. Hat values are open to interpretation, but a cut-off value that is common is twice or three times the average $\bar{h}$, meaning anything above that value should be looked at closer.

Let's add a cut-off line into the above hatvalue figure.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
# the average of hat-values
mean_h <- (1+1)/8

# adding a cut-off line
plot(hatvalues(mod))
abline(h = 2*mean_h, lty = 2)
abline(h = 3*mean_h, lty = 2)
```

As illustrated in the figure above, we can see that the value of $h_8$ is greater than twice and three times the mean hat values ($\bar{h}$). Based on this observation, we can safely conclude that the value of $h_8$ is highly unusual. In this case, $h_8$ is definitely unusual!

After having assessed leverage, let's look at discrepancy. How unusual is the $y$-value given its $x$-value?

#### 1.3 Assessing Discrepancy

As we learned earlier, data points that do not fit well to the linear regression line are referred to as outliers, or high-discrepancy points. Typically, we assess the fit of the regression line using residuals, which measure the distance between a predicted value and the actual value. While we already know that point 8 has high leverage, it is worth noting that the line of best fit is quite close to its predicted value (see the left panel). Additionally, when we examine the residuals, point 8 does not appear to be further from the regression line than any other points (see the right panel).


```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=4}
p1 <- ggplot(data = pubs, aes(x = pubs, y = deaths, label = name)) +
    geom_point(alpha = 0.8) +
    geom_text(hjust = 2, vjust = 0) +
    geom_smooth(method = lm, se = FALSE, colour = "darkorange") +
    xlab("Number of Pubs") + 
    ylab("Deaths") +
    theme_bw()

pubs2 <- pubs %>% mutate(residuals = residuals(mod))

p2 <- ggplot(data = pubs2, aes(x = pubs, y = residuals, label = name)) +
    geom_point(alpha = 0.8) +
    geom_text(hjust = 2, vjust = 0) +
    geom_hline(yintercept = 0, linetype = 2) +
    xlab("Number of Pubs") + 
    ylab("Residuals") +
    theme_bw()

ggpubr::ggarrange(p1, p2)
```
Instead, we can look at standardized or studentized residuals. 

- Standardized residuals are formed by calculating:

    $$E_i'=\frac{E_i}{S_E\sqrt{1-h_i}}$$
    <center>where $S_E=\sqrt{\frac{\sum E_i^2}{n-k-1}}$</center>
    
    Let's calculate the standardized residual for our example data by hand (the 8th data point is the one we're interested in):
    
    ```{r, message=FALSE}
# residual for data point in original model
Ei <- as.numeric(residuals(mod)[8])

# estimate of sigma (standard deviation) for residuals
S_E <- summary(mod)$sigma

# hatvalue for point 8
hi <- as.numeric(hatvalues(mod)[8])

# putting it together
Eprime <- Ei/(S_E*sqrt(1-hi))
Eprime
```
    
    You can also just let R do the maths by calling rstandard on the original model:
    
    ```{r, message=FALSE}
rstandard(mod)
```

    Note that the last value is the same as the one we calculated by hand! Let's compare the residuals and the studentized residuals in plots side by side:

    ```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=4}
pubs3 <- pubs %>% mutate(rstandard = rstandard(mod))

p3 <- ggplot(data = pubs3, aes(x = pubs, y = rstandard, label = name)) +
    geom_point(alpha = 0.8) +
    geom_text(hjust = 2, vjust = 0) +
    geom_hline(yintercept = 0, linetype = 2) +
    xlab("Number of Pubs") + 
    ylab("Standardized Residuals") +
    theme_bw()

ggpubr::ggarrange(p2, p3)
```

    The standardized residuals provide a better measure of discrepancy and can reveal outliers that were not detected by the normal residual plot. In our case, by looking at the standardized residual plot below, we can confirm that point 8 has a high discrepancy compared to the other points.


- Studentized residuals are calculated by fitting a model without the case for which the residual is calculated, and then scaling the resulting residual ($E_i$) by an estimate of the standard deviation of the residuals ($S_{E(-i)}$) and the point's hat value ($h_i$):

    $$E_i^*=\frac{E_i}{S_{E(-i)}\sqrt{1-h_i}}$$

    Let's calculate the studentized residual for our example data by hand (the 8th data point is the one we're interested in):

    ```{r, message=FALSE}
# model excluding point 8
mod.red <- lm(deaths ~ pubs, data = pubs[-8,]) 

# residual for data point in original model
Ei <- as.numeric(residuals(mod)[8])

# estimate of sigma (standard deviation) for residuals
S_E <- summary(mod.red)$sigma

# hatvalue for point 8
hi <- as.numeric(hatvalues(mod)[8])

# putting it together
Estar <- Ei/(S_E*sqrt(1-hi))
Estar
```

    You can also just let R do the maths by calling rstudent on the original model:

    ```{r, message=FALSE}
rstudent(mod)
```

    Note that the last value is the same as the one we calculated by hand! Let's compare the residuals and the studentized residuals in plots side by side:

    ```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=4}
pubs4 <- pubs %>% mutate(rstudent = rstudent(mod))

p4 <- ggplot(data = pubs4, aes(x = pubs, y = rstudent, label = name)) +
    geom_point(alpha = 0.8) +
    geom_text(hjust = 2, vjust = 0) +
    geom_hline(yintercept = 0, linetype = 2) +
    xlab("Number of Pubs") + 
    ylab("Studentized Residuals") +
    theme_bw()

ggpubr::ggarrange(p2, p4)
```

    The studentized residuals reveal clearly that point 8 has a high discrepancy, while this was not possible to see from the normal residual plots. You can also perform *Bonferroni adjustment* to test the statistical significance of the $E_8^*$ to check if we can confidently say that point 8 is an outlier. Observations are considered outliers if their `Bonferroni p` is less than .05.

    ```{r, message=FALSE}
library(car)
outlierTest(mod)
```

    According to the above test, we can say that point 8 can be considered an outlier (high discrepancy).


#### 1.4 Assessing Influence

As mentioned earlier, having high leverage or discrepancy alone does not necessarily mean a data point will have a high influence on the linear regression model. However, since our point of interest (point 8) has both high leverage and discrepancy, it is likely to have high influence on the model.

We'll use something called *Cook's D*, which relies on the standardized residuals to assess influence. A similar measure is *DFFITS*,  which instead is based on studentized residuals. Another measure we won't go into are *DFBETAS*, which measures the influence on each individual parameter, instead of the overall model.

Observations that combine high leverage with large studentized residual
exert substantial influence on regression coeffcients. Cook's D statistic
provides a summary index of influence.

<center> $D_i=\frac{E_i'^2}{k+1}\times \frac{h_i}{1-h_i}$ </center>

where the first term, the standardized residual, is a measure of discrepancy
and the second is a measure of leverage.The higher the leverage and residuals, the higher the Cook’s distance.

Several interpretations for Cook’s distance exist. There isn’t a universally accepted rule for cut off points.

- One interpretation is to investigate any point over $\frac{4}{n}$, where $n$ is the number of observations.
- Other scholars suggest that any "large" $D_i$ should be investigated. How large is "too large"? The consensus seems to be that a $D_i$ value of more than 1 indicates an influential value, but you may want to look at values above 0.5.

Let's use `influencePlot()` in the `car` package to check Cook's D statistics!

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
library(car)
influencePlot(mod)
```

#### 1.5 Added-variable Plot (AV Plot)

All the above techniques can also be applied to multivariate linear regression models. Additionally, we introduce another very useful influence graph for visually detecting outliers in multivariate linear models, known as an **added-variable plot** or **partial-regression plot**.

A limitation of using the typical residual plots in a multivariate linear regression model, such as plotting residuals against the values of a predictor variable, is that they may not fully illustrate the "additional contribution" of a predictor variable when considering other variables already in the model. Added-variable plots offer a more refined visualization, providing graphic insights into the marginal importance of a predictor variable, taking into account the presence of other variables in the model. The following materials are sourced from Fox's [slides](https://socialsciences.mcmaster.ca/jfox/Misc/CANSSI/Fox-CANSSI-notes.pdf) and [lecture](https://www.youtube.com/watch?v=cY1n-s3qE3c).

- Let $y_i^{(1)}$ represent the residuals from the least-squares regression of $y$ on all of the $x$s with the exception $x_1$, that is, the residuals from the fitted model:

    $$y_i = b_0^{(1)} + b_2^{(1)}x_{i2} + ...+ b_k^{(1)}x_{ik} + y_i^{(1)}$$
    
- Likewise, $x_i^{(1)}$ are residuals from the least-squares regression of $x_1$ on the other $x$s:

    $$x_{1i} = c_0^{(1)} + c_2^{(1)}x_{i2} + ...+ c_k^{(1)}x_{ik} + x_i^{(1)}$$

- The notation emphasizes the interpretation of the residuals $y_i^{(1)}$ and $x_i^{(1)}$ as the parts of $y$ and $x_1$ that remain when the linear dependence of these variables on $x_2, ..., x_k$ is removed.

The AV plot for $x_1$ is then the scatterplot of $y_i^{(1)}$ versus $x_i^{(1)}$, and we repeat the procedure for each $x_j$, $j =0, 1, ..., k$ (where $x_0 = 1$). In effect, the $(k+1)$-dimensional scatterplot for $y$ and $x_1, ..., x_k$ is reduced to a sequence of $k+1$ 2D AV plots. By doing so, the AV plots visualize leverage and influence on each of the regression coefficients.

The added-variable plot for $x_1$ has the following very interesting properties:

- The slope of the least-squares simple-regression line of of $y_i^{(1)}$ on $x_i^{(1)}$ is the same as the least-squares slope $b_1$ for $x_1$ in the full multiple regression.

- The residuals from this simple regression are the same as the residuals $e_i$ from the full regression.

- Consequently, the standard deviation of the residuals in the added-variable plot is the same as the multiple regression.

- The standard error of $b_1$ from this simple regression is also the same as the standard error from the full regression

- Because the $x_i^{(1)}$ are residuals, they are less variable than $x_1$ if $x_1$ is correlated with the other $x$s. The added-variable plot therefore show how collinearity can degrade the precision of the estimation by decreasing the conditional variation of an $x$.

**NOTE:** You may find these concepts very familiar as in POL 212, we have actually covered the Frisch-Waugh-Lovell Theorem (you can review the materials of *Discussion IV* in [POL 212 Discussion](https://yslhuang.github.io/method-sequence/212-Discussion.html)), in which we showed how to decompose a regression of $Y$ on a set of variables $X$ into two pieces. The coefficient of one of the variables in multiple linear regression model can be obtained by netting off effect of other variables in the regression model from both dependent and independent variables. The FWL Theorem shows that it is important to partial one set of covariates out of the other in order to obtain the ceteris paribus effect. For example, in order to get the effect of $X1$ on $Y$, $X2$ needs to be held constant, which involves removing the portion of $X1$ that is correlated with $X2$. Likewise, when identifying outliers among explanatory variables in a multivariate linear regression model, it's crucial to first hold all other variables constant.

##### Example

For this example, we will use the `Duncan` data frame, which has 45 rows and 4 columns. This is a dataset on the prestige and other characteristics of 45 U.S. occupations in 1950.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
library(car)
library(carData)

knitr::kable(head(Duncan)) # from carData package
```

These are the description of each variable:

- `type`: Type of occupation. A factor with the following levels: prof, professional and managerial; wc, white-collar; bc, blue-collar.

- `income`: Percentage of occupational incumbents in the 1950 US Census who earned $3,500 or more per year (about $36,000 in 2017 US dollars).

- `education`: Percentage of occupational incumbents in 1950 who were high school graduates (which, were we cynical, we would say is roughly equivalent to a PhD in 2017).

- `prestige`: Percentage of respondents in a social survey who rated the occupation as “good” or better in prestige.


Let's begin by regressing `prestige` on all explanatory variables `income` and `education`, then plot the added-variable plots to visually inspect for any potential outliers.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
m.duncan <- lm(prestige ~ income + education, data = Duncan)
```

```{r, message=FALSE, echo=FALSE}
sjPlot::tab_model(m.duncan, show.se = TRUE, string.se = "S.E.",
                  dv.labels = c("OLS"), string.pred = "Variables", 
                  string.ci = "C.I. (95%)", p.style = "stars", 
                  file = "output.html")
```

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=4}
avPlots(m.duncan)
```

Note that the slope of the blue regression line in both plots corresponds to the estimated coefficient of income and education in our multivariate regression model.


In the AV plots, we can observe the impact (or lack thereof) of these unusual cases on the regression coefficients. Let's first examine the left-hand side of the figure. We notice that the case of the minister pulls up on the left side, while the case of the conductor pulls down on the right side. This influential pair is widely separated, affecting the coefficient of income by making it smaller than it would otherwise be. The case of railroad engineers appears as a very high leverage point due to their unusual income given their education level, but it aligns more or less with the trend observed throughout the data. Similarly, the case of the reporter also follows the overall trend.

Similarly, in the education AV plots, we observe a similar trend except for the effect of the minister's case, which pulls up on the left side, leading to a larger coefficient of education than it would otherwise be. Again, the cases of railroad engineers and reporters seem to align with the general trend of the data, requiring less concern.

Overall, based on the AV plots, we may speculate that the case of the minister could be an influential data point affecting our model's estimation. We can proceed by updating our original regression model and then comparing the coefficients between the models to validate this hypothesis.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=4}
m.duncan2 <- lm(prestige ~ income + education, 
                data = subset(Duncan, !(rownames(Duncan) %in% c("minister"))))

```

```{r, message=FALSE, echo=FALSE}
sjPlot::tab_model(m.duncan, m.duncan2, show.se = TRUE, 
                  string.se = "S.E.", dv.labels = c("Model 1", "Model 2"), 
                  string.pred = "Variables", string.ci = "C.I. (95%)",
                  p.style = "stars", file = "output.html")
```

Indeed, after excluding the case of the minister, the coefficient of income increases from 0.6 to 0.73, while the coefficient of education decreases from 0.55 to 0.43.

We can also run the `influencePlot()` to check if the Cook's distance of the minister's case is indeed very problematic or not.

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.align='center', fig.width=5, fig.height=4}
influencePlot(m.duncan)
```

### 2. Diagnostics for Linearity and Errors

#### 2.1 Violation of Linearity Assumption

Recall the linearity assumption is that the expected (mean) value of the disturbance term is 0 (i.e., $E(u_i)=0$). The average regression error is 0 everywhere implies that the regression surface captures the dependency of the conditional mean of $y$ on $x$s. Violating the linearity assumption implies "that the model fails to capture the systematic pattern of relationship between the response and explanatory variables" (Fox, 2016: 307). For example, a partial relationship specified to be linear may be nonlinear, or two explanatory variables specified to have additive partial effects may interact in determining $y$. While a fitted model may sometimes provide a useful approximation to the true regression surface $E(y)$, there are instances where the model can be highly misleading. You can think of nonlinearity (fitting the wrong equation to the data) as potentially the most serious problem with a regression model.

When performing a linear regression with a single explanatory variable, a scatterplot of the response variable against the explanatory variable provides a good indication of the nature of the relationship. If there is more than one explanatory variable, things become more complicated. Although it can still be useful to generate scatterplots of the response variable against each of the explanatory variables, this does not take into account the effect of the other explanatory variables in the model. After all, our interest centers on the partial relationship between $y$ and each $x$, controlling for the other $x$s, not on the *marginal* relationship between y and a single $x$.

Furthermore, while plotting residuals against each $x$ is helpful for detecting departures from linearity, residual plots cannot distinguish between monotone and nonmonotone nonlinearity.

<center>![](/Users/yu-shiuanhuang/Desktop/method-sequence/figures/crplots.png){width="60%"}</center>

In the above figure from the Fox textbook, case (a) might be modeled by $y = \beta_0 + \beta_1\sqrt{x} + \varepsilon$ (a transformation of $x$), but case (b) cannot be linearied by a transformation of $x$ and might instead be dealt with a quadratic regression, $y = \beta_0 + \beta_1x + \beta_2x^2  + \varepsilon$.

Component + residual (C+R) plots, an extension of partial residual plots, are a good way to see if each predictor you include in the multivariate linear model have a linear relationship to the dependent variable. A partial residual plot essentially attempts to model the residuals of one predictor against the dependent variable. The partial residual for the $j$th explanatory variables is defined as:

$$E_{i}^{(j)}= E_i+B_jX_{ij}$$

In words, add back the linear component of the partial relationship between $Y$ and $X_j$ to the least-squares residuals, which may include an **unmodeled nonlinear component**. Then plot $E^{(j)}$ versus $X_j$.

##### Example

Let's do a simulation example to see how C+R plots can help distinguish monotone and nonmonotone nonlinearity.

```{r, message=F}
set.seed(1234) # for replication
N <- 100 # set up the sample size
x1 <- rnorm(N, mean = 4, sd = 5)
x2 <- runif(N, min = -5, max = 5)
x3 <- rnorm(N, mean = 10, sd = 2)*(x1/2)
cor(x1, x3)
e <- rnorm(N, mean = 0, sd = 1) # set the errors to be normally distributed 
y <- 7 + x1^2 + x2 + 5*x2^2 - 7*x3 + e # set the true y
df <- data.frame(y = y, x1 = x1, x2 = x2, x3 = x3, e = e)
```

In the above chunk, I define the true value $y$ as a function of $x_1$, $x_2$, $x_3$, and the error term ($e$). Specifically, the true regression coefficients are set as follows: $1$ for the squared transformation of $x_1$, $1$ for $x_2$, and $-7$ for $x_3$. Additionally, the term $5 \cdot x_2^2$ signifies a quadratic effect of $x_2$, while the intercept is fixed at $7$. Note, I sepcifically set $x_3$ to be highly correlated with $x_1$. To visualize the underlying relationship between $x_1$, $x_2$, $x_3$, and $y$, let's start by plotting scatterplots for each pair of $y$ and $x$, then running a multivariate regression, and plotting residuals against each $x$.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=8}
fit <- lm(y ~ x1 + x2 + x3, data = df)
df$residual <- fit$residuals

library(tidyverse)

p1 <- ggplot(data = df, aes(x = x1, y = y)) +
  geom_point(color = "gray37", alpha = 0.7) +
  geom_smooth(color = "salmon2", alpha = 0.3) +
  labs(subtitle = "Scatterplot between y and each x") +
  theme_bw()
  
p2 <- ggplot(data = df, aes(x = x1, y = residual)) +
  geom_point(color = "gray37", alpha = 0.7) +
  geom_smooth(method = "lm", color = "steelblue2", alpha = 0.3) +
  labs(subtitle = "Residuals against each x") +
  theme_bw()

p3 <- ggplot(data = df, aes(x = x2, y = y)) +
  geom_point(color = "gray37", alpha = 0.7) +
  geom_smooth(color = "salmon2", alpha = 0.3) +
  theme_bw()
  
p4 <- ggplot(data = df, aes(x = x2, y = residual)) +
  geom_point(color = "gray37", alpha = 0.7) +
  geom_smooth(method = "lm", color = "steelblue2", alpha = 0.3) +
  theme_bw()

p5 <- ggplot(data = df, aes(x = x3, y = y)) +
  geom_point(color = "gray37", alpha = 0.7) +
  geom_smooth(color = "salmon2", alpha = 0.3) +
  theme_bw()
  
p6 <- ggplot(data = df, aes(x = x3, y = residual)) +
  geom_point(color = "gray37", alpha = 0.7) +
  geom_smooth(method = "lm", color = "steelblue2", alpha = 0.3) +
  theme_bw()
  
ggpubr::ggarrange(p1, p2, p3, p4, p5, p6, ncol = 2, nrow = 3)

```
From the scatterplots of $y$ against $x_1$ and $x_2$, as well as their respective residual plots, it's evident that while plotting residual plots can indicate whether our model violates the linearity assumption, it doesn't provide insight into the underlying reasons for the violation. Notably, the residuals plotted against both $x_1$ and $x_2$ exhibit a similar convex pattern. Moreover, scatterplots of $y$ against $x_1$ and $x_2$ do not accurately depict their partial relationship. Simply plotting scatterplots between variables fails to consider the influence of other variables in the model, particularly when there are high correlations among predictors. Let's do the C+R plots instead.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=6}
crPlots(fit)
```

The magenta line represents a smooth curve through the C+R plots, while the blue dashed line represents the regression coefficient of each $x$ from the multivariate regression model. A notable disparity between the residual line and the component line suggests that the predictor does not exhibit a linear relationship with the response variable. Once again, the advantage of using C+R plots is that they provide information about the partial relationship between $y$ and each $x$ while controlling for all other variables. Additionally, they offer insight into how to address nonlinearity. To address the nonlinearity in $x_1$, applying a square transformation often resolves the issue effectively. As for $x_2$, we need to consider the quadratic relationship between $y$ and $x_2$.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=6}
df$x1_square <- (df$x1)^2
fit_update <- lm(y ~ x1_square + poly(x2, 2, raw = TRUE) + x3, data = df)
crPlots(fit_update)
```

#### 2.2 Violation of Homoskedasticity Assumption 

Note: the materials for this section draw from [Penn State STAT 501](https://online.stat.psu.edu/stat501/lesson/13/13.1) and [here](https://www.statology.org/weighted-least-squares-in-r/).

The method of ordinary least squares assumes that there is constant variance in the errors (which is called homoscedasticity). The method of **weighted least squares** can be used when the ordinary least squares assumption of constant variance in the errors is violated (which is called heteroscedasticity). The model under consideration is:

$$Y = X\beta + \epsilon^*$$
where $\epsilon^*$ is assumed to be (multivariate) normally distributed with mean vector 0 and nonconstant variance-covariance matrix.

$$\begin{equation*} \left(\begin{array}{cccc} \sigma^{2}_{1} & 0 & \ldots & 0 \\ 0 & \sigma^{2}_{2} & \ldots & 0 \\ \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & \ldots & \sigma^{2}_{n} \\ \end{array} \right) \end{equation*}$$

If we define the reciprocal of each variance, $\sigma_i^2$, as the weights, $w_i = 1/\sigma_i^2$, then let matrix W be a diagonal matrix containing these weights:

$$\begin{equation*}\textbf{W}=\left( \begin{array}{cccc} w_{1} & 0 & \ldots & 0 \\ 0& w_{2} & \ldots & 0 \\ \vdots & \vdots & \ddots & \vdots \\ 0& 0 & \ldots & w_{n} \\ \end{array} \right) \end{equation*}$$
The weighted least squares estimate is then:

$$\begin{align*} \hat{\beta}_{WLS}&=\arg\min_{\beta}\sum_{i=1}^{n}\epsilon_{i}^{*2}\\ &=(\textbf{X}^{T}\textbf{W}\textbf{X})^{-1}\textbf{X}^{T}\textbf{W}\textbf{Y} \end{align*}$$
With this setting, we can make a few observations:

- Since each weight is inversely proportional to the error variance, it reflects the information in that observation. So, an observation with a small error variance has a large weight since it contains relatively more information than an observation with a large error variance (small weight).
- The weights have to be known (or more usually estimated) up to a proportionality constant.
- Weighted least squares estimates of the coefficients will usually be nearly the same as the "ordinary" unweighted estimates. In cases where they differ substantially, the procedure can be iterated until estimated coefficients stabilize (often in no more than one or two iterations); this is called iteratively reweighted least squares.
- The use of weights will (legitimately) impact the widths of statistical intervals.

##### Example

Let's simulate the violation of homoskedasticity assumption and apply the method of weighted least squares to address it.

```{r, message=F, warning=F}
set.seed(1234) # for replication
N <- 1000 # set up the sample size
x1 <- 1:N
x2 <- rnorm(N, mean = 10, sd = 3)
sd <- runif(N, min = 0, max = 2)
e <- rnorm(N, mean = 0, sd = 2*x1) # set the errors to be normally distributed but not at a constant variance
y <- 7 + 3*x1 + x2 + e # set the true y
df <- data.frame(y = y, x1 = x1, x2 = x2, e = e)
```

In the above chunk, I set the error variance to be more pronounce: as $x1$ gets larger, the error variance gets larger by multiplying $x1$. You can see this relationship in the below figure.

```{r, message=F, warning=F, fig.align='center', fig.width=6, fig.height=4}
ggplot(data = df, aes(x = x1, y = e)) +
  geom_point(color = "gray37", alpha = 0.7) +
  theme_bw()
```

Let's now run the regression and test it to see if it violates the homoskedasticity assumption.

```{r, message=F, warning=F}
fit <- lm(y ~ x1 + x2, data = df) 
```

```{r, message=FALSE, echo=FALSE}
sjPlot::tab_model(fit, show.se = TRUE, string.se = "S.E.",
                  dv.labels = c("OLS"), string.pred = "Variables", 
                  string.ci = "C.I. (95%)", p.style = "stars", 
                  file = "output.html")
```

According to the regression table, you can see that the standard error of $x2$ is very large, which is due to the heteroskedasticity problem in our data. The estimate of the effect of $x2$, therefore, is very inefficient.

```{r, message=F, warning=F, fig.align='center', fig.width=6, fig.height=6}
par(mfrow = c(2, 2))
plot(fit)
```

Let's take a look at the third plot. Scale-Location is used to check the homogeneity of variance of the residuals (homoscedasticity). Horizontal line with equally spread points is a good indication of homoscedasticity. This is not the case in our example, where we have a heteroscedasticity problem. It can be seen that the variability (variances) of the residual points increases with the value of the fitted outcome variable, suggesting non-constant variances in the residuals errors.

To formally test for heteroscedasticity, we can perform a **Breusch-Pagan test**:

```{r, message=F, warning=F, fig.align='center', fig.width=6, fig.height=6}
# load lmtest package
library(lmtest)

# perform Breusch-Pagan test
bptest(fit)
```

The Breusch-Pagan test uses the following null and alternative hypotheses:

- Null Hypothesis ($H_0$): Homoscedasticity is present (the residuals are distributed with equal variance)
- Alternative Hypothesis ($H_A$): Heteroscedasticity is present (the residuals are not distributed with equal variance)

Since the p-value from the test is < 2.2e-16, we will reject the null hypothesis and conclude that heteroscedasticity is a problem in this model.

Since heteroscedasticity is present, we will perform weighted least squares by defining the weights in such a way that the observations with lower variance are given more weight:

```{r, message=F, warning=F, fig.align='center', fig.width=6, fig.height=6}
# define weights to use
wt <- 1 / lm(abs(fit$residuals) ~ fit$fitted.values)$fitted.values^2

head(lm(abs(fit$residuals) ~ fit$fitted.values)$fitted.values)
head(wt)
```


```{r, message=F, warning=F, fig.align='center', fig.width=6, fig.height=6}
# perform weighted least squares regression
wls_fit <- lm(y ~ x1 + x2, data = df, weights = wt)
```


```{r, message=FALSE, echo=FALSE}
sjPlot::tab_model(fit, wls_fit, show.se = TRUE, string.se = "S.E.",
                  dv.labels = c("No WLS", "WLS"), 
                  string.pred = "Variables", 
                  string.ci = "C.I. (95%)", p.style = "stars", 
                  file = "output.html")
```

The weighted least squares model yields a coefficient for $x_2$ much closer to its true value compared to the original model. Additionally, the residual standard error in the WLS model is smaller than that in the original multivariate linear regression model. These results suggest that the predicted values generated by the weighted least squares model are much closer to the actual observations than those produced by the original model.

The weighted least squares model also has an R-squared of 0.648 compared to 0.371 in the original multivariate linear regression model. This indicates that the weighted least squares model is able to explain more of the variance in y compared to the original multivariate linear regression model.

## Discussion IV

For today’s discussion, we will review what multicollinearity is, how to detect it, and introduce Principal Component Analysis (PCA) as one of the methods to handle it.

1. (Multi)collinearity Problem
2. Detecting Collinearity
3. Principle Component Analysis (PCA)

### 1. (Multi)collinearity Problem

In multivariate linear regression, it is possible for two or more predictor variables to be correlated with each other. This scenario is referred to as collinearity. In extreme cases, where collinearity exists between three or more variables, even if no pair of variables has a particularly high correlation, this is known as multicollinearity. Multicollinearity indicates redundancy between predictor variables.

The presence of multicollinearity can cause the solution of the regression model to become unstable. 

- coefficient standard errors are large reflecting imprecision 
- broad confidence intervals 
- hypothesis test have low power

Therefore, it is important to detect and address multicollinearity before building a regression model to ensure the model's reliability and accuracy.

#### 1.1 Example of Perfect Multicollinearity Problem

Let's first review what Lauren discussed in the lecture regarding why it's not feasible to include all the dummies of a categorical variable .

```{r, warning = FALSE, message = FALSE}
library(AER)
library(MASS)
data(CASchools)

# define variables
CASchools$STR <- CASchools$students/CASchools$teachers 
CASchools$score <- (CASchools$read + CASchools$math)/2 

# set seed for reproducibility
set.seed(1)

# generate artificial data on location
CASchools$direction <- sample(c("West", "North", "South", "East"), 420, replace = T)
head(CASchools[, c("score", "STR", "english", "direction")])
```

In this example, our response variable is `score`, and explanatory variables are `STR`(student-teacher ratio), `english` (the share of English learning students), and `direction` (artificial location of a
school).

```{r, warning = FALSE, message = FALSE}
mod1 <- lm(score ~ STR + english + direction, data = CASchools)
```

```{r, message=FALSE, echo=FALSE}
sjPlot::tab_model(mod1, show.se = TRUE, string.se = "S.E.",
                  dv.labels = c("Score"), 
                  string.pred = "Variables", 
                  string.ci = "C.I. (95%)", p.style = "stars", 
                  file = "output.html")
```

In the regression table above, you'll notice that R has included only three of the dummies for the direction variable and has designated the category `East` as the reference group in the model. What this means is that when interpreting the coefficients of the remaining three categories of the `direction` variable, we are comparing their effects to the category `East`. For instance, we can infer that schools located in the North have, on average, 1.66 higher test scores than schools located in the East. Although this difference is not statistically significant, as the variable was artificially generated.

In addition, since the category `East` was designated as the reference group, the value of the intercept reflects that the baseline test score of a school is when schools have a student-teacher ratio of 0, no English learning students, and are located in the East. The modelpredicts that the average test score of such schools is 684.80.

What would happen if we intentionally include four dummies of the `direction` variable in the model?

```{r, message=FALSE, warning=FALSE}
library(fastDummies)
CASchools <- dummy_cols(CASchools, select_columns = "direction")
head(CASchools[,c("score", "STR", "english", "direction_East", 
                  "direction_North", "direction_South", "direction_West")])
```

```{r, warning = FALSE, message = FALSE}
mod2 <- lm(score ~ STR + english + direction_North + direction_South + 
               direction_West + direction_East , data = CASchools)
```


```{r, message=FALSE, echo=FALSE}
sjPlot::tab_model(mod1, mod2, show.se = TRUE, string.se = "S.E.",
                  dv.labels = c("Model 1", "Model 2"), 
                  string.pred = "Variables", 
                  string.ci = "C.I. (95%)", p.style = "stars", 
                  file = "output.html")
```


As you can observe in model 2, R automatically dropped one of the dummies of the `direction` variable (`East`). R does this to solve the perfect multicollinearity problem. Where is the perfect
multicollinearity problem in this case? 

Recall from the materials in Discussion II, we talk about how to think of our data set as a matrix. The below equations are how each observation in our data set generated.

<center>

$Y_1=\beta_0+\beta_1X_{11}+\beta_2X_{12}+...+\beta_kX_{1k}+\varepsilon_1$

$Y_2=\beta_0+\beta_1X_{21}+\beta_2X_{22}+...+\beta_kX_{2k}+\varepsilon_2$

.

.

.

$Y_n=\beta_0+\beta_1X_{n1}+\beta_2X_{n2}+...+\beta_kX_{nk}+\varepsilon_n$

</center>

Rewrite them into a matrix form.

<center>![](/Users/yu-shiuanhuang/Desktop/method-sequence/figures/matrix.png){width="50%"}</center>

The system of equations is summarized as the *y* vector equal to the product of the *X* matrix of data times the *$\beta$* vector of parameters plus the vector of disturbances, $\varepsilon$. In the lecture, Lauren showed how to apply what we did when finding a pair of intercept and slope in simple linear regression to solve the optimization problem to find the coefficient vector *b* using matrix algebra. Instead of taking derivative with respect to each coefficient one at a time, we can take derivative directly with respect to the coefficient vector *b*. Therefore, the least squares estimator is:

<center>

$\hat{\beta}=(X'X)^{-1}X'y$

</center>

In the matrix algebra for estimating $\beta$ coefficients using the above equation, it is necessary for the first column of the $X$ matrix to be composed of 1s. This is because the first column represents the intercept term in the regression model. Therefore, including all the dummies of a categorical variable in a regression model would result in a perfect multicollinearity problem beacuse they are the linear combination of the intercept term.

Let's relook at the `CASchools` again.

```{r, message=FALSE, warning=FALSE}
head(CASchools[,c("score", "STR", "english", "direction_East", 
                  "direction_North", "direction_South", "direction_West")])
```

The linear combination of the intercept term equals to the sum of `direction_East`, `direction_North`, `direction_South`, `direction_West`, resulting in a perfect multicollinearity problem.

```{r, message=FALSE, warning=FALSE}
CASchools$intercept <- CASchools$direction_East + CASchools$direction_North + 
    CASchools$direction_South + CASchools$direction_West

head(CASchools[,c("score", "STR", "english", "direction_East", 
                  "direction_North", "direction_South", "direction_West", "intercept")])
```

#### 1.2 Example of Imperfect Multicollinearity Problem

If there is high multicollinearity between variables but not perfectly correlated, `lm()` will still spit out the estimates of the highly correlated variable. However, the standard errors of coefficients will be very high, which means that our estimates will be highly unstable.

```{r, warning=FALSE, message=FALSE}
set.seed(1234)

# generate a highly correlated variable
CASchools$english_hc1 <- 2*CASchools$english + rnorm(nrow(CASchools), 10, 5)

cor(CASchools$english_hc1, CASchools$english) # english_hc is highly but not perfectly correlated with english
```

```{r, warning=FALSE, message=FALSE}
set.seed(1234)

# generate a less highly correlated variable
CASchools$english_hc2 <- 2*CASchools$english + rnorm(nrow(CASchools), 10, 20)

cor(CASchools$english_hc2, CASchools$english) 
```


```{r, warning = FALSE, message = FALSE}
mod3 <- lm(score ~ STR + english , data = CASchools) # without highly correlated term
mod4 <- lm(score ~ STR + english + english_hc1 , data = CASchools) # with highly correlated term
mod5 <- lm(score ~ STR + english + english_hc2 , data = CASchools) # with less highly correlated term
```

```{r, message=FALSE, echo=FALSE}
sjPlot::tab_model(mod3, mod4, mod5, show.se = TRUE, 
                  string.se = "S.E.",
                  dv.labels = c("Model 1", "Model 2", "Model 3"), 
                  string.pred = "Variables", 
                  string.ci = "C.I. (95%)", p.style = "stars", 
                  file = "output.html")
```

The regression output indicates that in models 2 and 3, there is an imperfect multicollinearity problem, which is reflected by an increase in the standard error of the coefficient estimates. Specifically, the estimated effect of `english` becomes increasingly unstable as the correlation between `english` and the correlated term (which we artificially generated) becomes stronger.

### 2. Detecting Collinearity 

Multicollinearity in a regression model can be assessed by computing the **variance inflation factor (VIF)** for each predictor variable. VIF measures how much of the variation in one variable is explained by the other variable. This is done by running a regression using one of the correlated $x$ variables as the dependent variable against the other variables as predictor variables. The VIF is calculated as one divided by the tolerance, which is defined as one minus R-squared.

<center>$VIF_j = \frac{1}{1-R_j^2}$ </center>

A VIF value of 1 indicates an absence of multicollinearity, while values exceeding 5 or 10 suggest problematic collinearity (James et al., 2014). When multicollinearity is detected, it is recommended to remove one or more of the correlated variables from the model. This is because the presence of multicollinearity implies that the information provided by the correlated variables about the response variable is redundant in the presence of other variables (James et al., 2014; P. Bruce & Bruce, 2017).

The R function `vif()` in the `car` package can be used to detect multicollinearity in a regression model:

```{r, warning = FALSE, message = FALSE}
library(car)
vif(mod3) # without highly correlated term
```

```{r, warning = FALSE, message = FALSE}
vif(mod4) # with highly correlated term
```

```{r, warning = FALSE, message = FALSE}
vif(mod5) # with less highly correlated term
```

As anticipated, when we include a highly correlated term in the model, both `english` and `english_hc1` exhibit extremely high VIF scores. 

### 3. Principal Components Analysis (PCA)

Principal Components Analysis (PCA), which is an unsupervised machine learning technique, can help handle multicollinearity problems by creating new features that are orthogonal to each other, meaning that they have zero correlation. This eliminates the problem of having features that are redundant or that inflate the variance of your model coefficients.

The goal of PCA is to explain most of the variability in a dataset with fewer variables than the original dataset. PCA offers a way to find a low-dimensional representation of a dataset that captures as much of the variation in the data as possible. If we’re able to capture most of the variation in just two dimensions, we could project all of the observations in the original dataset onto a simple scatterplot.

The way we find the principal components is as follows:

Given a dataset with $p$ predictors: $X_1$, $X_2$,..., $X_p$, calculate $Z_1$,..., $Z_M$ to be the $M$ linear combinations of the original $p$ predictors where:

- $Z_m = \Sigma \Phi_{jm}X_j$ for some constants $\Phi_{1m}$, $\Phi_{2m}$,..., $\Phi_{pm}$, $m = 1, 2,...,M$.
- $Z_1$ is the linear combination of the predictors that captures the most variance possible.
- $Z_2$ is the next linear combination of the predictors that captures the most variance while being orthogonal (i.e. uncorrelated) to $Z_1$.
- $Z_3$ is then the next linear combination of the predictors that captures the most variance while being orthogonal to $Z_2$.
- And so on.

In practice, we use the following steps to calculate the linear combinations of the original predictors:

1. Scale each of the variables to have a mean of 0 and a standard deviation of 1.

2. Calculate the covariance matrix for the scaled variables.

3. Calculate the eigenvalues of the covariance matrix.

Using linear algebra, it can be shown that the eigenvector that corresponds to the largest eigenvalue is the first principal component. In other words, this particular combination of the predictors explains the most variance in the data.

The eigenvector corresponding to the second largest eigenvalue is the second principal component, and so on.

#### Example

For this example, we will use the "Communities and Crime" dataset from the UCI Machine Learning Repository, created by Michael Redmond. This dataset includes various socio-economic, law enforcement, and crime data. A cleaned version is available in the `mogavs` package under the name `crimeData`, which has been simplified by removing all columns identified as redundant by the dataset's author, reducing the number of columns from 128 to 123.

We will use this dataset from the `mogavs` package for our analysis. The outcome variable we are focusing on is violent crimes per capita, while the independent variables include aspects of law enforcement, socio-economic factors, and crime data. A detailed description of all these variables can be found [here](http://archive.ics.uci.edu/ml/datasets/communities+and+crime).

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=8}
library(mogavs)
dim(crimeData)
colnames(crimeData)
```

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=8}
# initialize
crimeData.y <- crimeData$y # set y as a vector out of the original data  
crimeData.X <- crimeData[, -123] # takeout y
```

By plotting the correlation matrix among predictors, we observe significant correlations between some variables, suggesting potential multicollinearity issues if all variables are included in the model.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
res <- cor(crimeData.X, method = "pearson")
corrplot::corrplot(res, method= "color", 
                   order = "hclust", tl.pos = 'n')
```

As you compute the Variance Inflation Factor (VIF) for each predictor, you will notice that many variables have VIF scores exceeding 5 or 10, indicating potentially problematic multicollinearity.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
fit <- lm(y ~ ., data = crimeData)
summary(fit)$r.squared
round(vif(fit), 2)
```

Instead of arbitrarily dropping variables from our model to address multicollinearity, we can perform principal component analysis (PCA). This approach allows us to identify principal components that capture most of the variance in the data with fewer variables, thus avoiding multicollinearity and leading to more efficient estimates.

Now, the first procedure for PCA is to scale and center the data using `prcomp` command. This command is both convenient and useful, helping you to subtract each observation value by its mean and then divide the result by the standard deviation. Then, we can use `print` and `summary` commands to see the rotation, standard deviation and proportion of variance each component contributes to the dataset, and use `fviz_fig` in package `factoextra` to plot a nice formatted scree plot.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
pca <- prcomp(crimeData.X, center = TRUE, scale. = TRUE)
summary(pca)
```

In the summary part, the line Proportion of Variance represents how much percentage of the variance is explained by each component. Here the first component explains 21.54% of the variability, the second component explains 15.05% of the variance and so on… Then the line Cumulative Proportion represents the percentage of variance explained by first k elements. Specifically, PC41 column gives the value 0.95138, which means if we include the first 41 components, then 95.14% of the variance is explained.

Note that the principal components scores for each observation are stored in `pca$x`. 

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
# display principal components
head(pca$x)
```

Let’s revisit the correlation plot. As the principal components are orthogonal, they exhibit no correlation. Consequently, the correlation plot appears perfectly white, except for instances of autocorrelation.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
res2 <- cor(pca$x, method = "pearson")
corrplot::corrplot(res2, method= "color", 
                   order = "hclust", tl.pos = 'n')
```

One challenge of using PCA is deciding how many principal components to retain. Retaining too many may not sufficiently reduce dimensionality, potentially maintaining multicollinearity. Conversely, keeping too few can lead to significant information loss, reducing the accuracy of your model. A widely used method to determine the optimal number of principal components is the scree plot. This plot displays the eigenvalues of the principal components in descending order and identifies where an abrupt change in the slope occurs, signaling a drop in the importance of subsequent components. The ideal pattern is a steep curve, followed by a bend, and then a straight line. Use the components in the steep curve before the first point that starts the line trend.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
factoextra::fviz_eig(pca, barfill = "gray73", barcolor = "gray73",
                     linecolor = "steelblue2", xlab = "Principle Component", ncp = 30)
```

As shown in the scree plot above, at first glance, it appears that the curve starts to level off from PC10, suggesting that including the first 9 components may be optimal. According to the summary results of the PCA object, including these first 9 components explains 70.85% of the variance.

Now let's rerun the model with 9 principal components and compute the VIF scores for each component. As shown below, all the VIF scores are 1, confirming the absence of multicollinearity as previously indicated by the correlation matrix. Instead of including numerous correlated variables, which could lead to inefficient estimates, the revised model now offers a more efficient set of estimates. Moreover, it still explains a significant portion of the variance in the outcome variable, with an $R^2$ of 0.6261, only slightly lower than the 0.6979 of the original model.

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=6, fig.height=4}
crimeData.pca <- as.data.frame(cbind(y = crimeData.y, pca$x[, 1:9]))
fit_pca <- lm(y ~ ., data = crimeData.pca)
summary(fit_pca)$r.squared
round(vif(fit_pca), 2)
```

For a more stringent method to determine how many principal components should be included in the linear regression model, please see [here](https://jbhender.github.io/Stats506/F17/Projects/G18.html) for an example.

Another challenge of using PCA is to interpret the meaning of the principal components. Unlike the original features, which may have a clear definition and unit, the principal components are abstract and hard to explain. One way to interpret the principal components is to look at the coefficients of the linear combination that forms each component. These coefficients indicate how much each original feature contributes to the component and what is the direction of the relationship. For example, if a component has a high positive coefficient for a feature, it means that the component increases with the feature. 

The function `fviz_contrib` function from `factoextra` package can be used to draw a bar plot of variable contributions. If your data contains many variables, you can decide to show only the top contributing variables. The R code below shows the top 50 variables contributing to the first principal component we have in this example:

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=4}
factoextra::fviz_contrib(pca, choice = "var", axes = 1, top = 50, 
                         fill = "gray73", color = "gray73")


```
The red dashed line on the graph above indicates the expected average contribution. If the contribution of the variables were uniform, the expected value would be 1/length(variables) = 1/122 = 0.82%. For a given component, a variable with a contribution larger than this cutoff could be considered as important in contributing to the component.

For instance, in the linear regression model where we include principal components instead of the original variables, there is a negative relationship between our outcome variable, violent crimes per capita, and PC1. According to the contribution plot, variables such as x.V25, x.V18, x.V50, and others above the red dashed line indicate that the relationship between our outcome variable and these variables is likely negative.


## Discussion V

TBD

## Discussion VI

TBD
